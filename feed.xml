<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.1">Jekyll</generator><link href="https://kozodoi.me/feed.xml" rel="self" type="application/atom+xml" /><link href="https://kozodoi.me/" rel="alternate" type="text/html" /><updated>2024-11-16T14:35:50-06:00</updated><id>https://kozodoi.me/feed.xml</id><title type="html">ABHISHEK SINGH</title><subtitle>ProjeKts and PaPers on AI, ML and other cool acronyms</subtitle><entry><title type="html">Disease Recognizer</title><link href="https://kozodoi.me/blog/20240801/disease-detection" rel="alternate" type="text/html" title="Disease Recognizer" /><published>2024-08-01T00:00:00-05:00</published><updated>2024-08-01T00:00:00-05:00</updated><id>https://kozodoi.me/blog/20240801/Disease-Recognizer-using-word-embeddings</id><content type="html" xml:base="https://kozodoi.me/blog/20240801/disease-detection"><![CDATA[<h1>Overview</h1>
<p><img src="https://github.com/user-attachments/assets/3a780226-bb0c-425a-9316-3872f465b5ad" alt="rick-and-morty-morty-smith" /></p>

<p>Disease Recognizer uses sentence embeddings generated by the <code>sentence-transformers/all-MiniLM-L6-v2</code> model to encode patient symptoms into a high-dimensional space. Machine learning algorithms, including Logistic Regression and KMeans Clustering, are employed to classify and group symptoms, ultimately predicting the associated disease.</p>

<h2>Features</h2>
<p><img src="https://github.com/user-attachments/assets/055eb59d-6561-4f9e-9797-db6f97202dc2" alt="CN_Final" /></p>

<ul>
    <li><strong>Symptom Embedding</strong>: Converts text-based symptoms into embeddings using a pre-trained transformer model.</li>
    <li><strong>Disease Prediction</strong>: Classifies symptoms into disease categories using Logistic Regression.</li>
    <li><strong>Clustering</strong>: Groups similar symptoms using KMeans Clustering.</li>
    <li><strong>Data Visualization</strong>: Visualizes the embedded symptom data using t-SNE plots.</li>
    <li><strong>Interactive Prediction</strong>: Allows for real-time disease prediction based on new symptom inputs.</li>
</ul>

<h2>Direct Run</h2>
<p>Go to this URL: <a href="https://disease-recogniser-nlp-team-ais.streamlit.app/">https://disease-recogniser-nlp-team-ais.streamlit.app/</a></p>

<h3>Repo Link</h3>
<p>LINK -&gt; https://github.com/Abhi2april/Disease-Recogniser</p>]]></content><author><name>Abhishek Singh.</name></author><category term="Health-Tech" /><category term="natural language processing" /><category term="web app" /><summary type="html"><![CDATA[Disease Recognizer takes what patients describe (their symptoms), converts that information into a format that computers can understand (numbers), and then uses machine learning techniques to find patterns and make predictions about the disease the patient might have .]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://kozodoi.me/images/posts/content.png" /><media:content medium="image" url="https://kozodoi.me/images/posts/content.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Medical content creation in the age of generative AI</title><link href="https://kozodoi.me/blog/20240703/medical-content-generation" rel="alternate" type="text/html" title="Medical content creation in the age of generative AI" /><published>2024-07-03T00:00:00-05:00</published><updated>2024-07-03T00:00:00-05:00</updated><id>https://kozodoi.me/blog/20240703/medical-content</id><content type="html" xml:base="https://kozodoi.me/blog/20240703/medical-content-generation"><![CDATA[<p>This post was originally published on the <a href="https://aws.amazon.com/blogs/machine-learning/medical-content-creation-in-the-age-of-generative-ai/">AWS ML Blog</a></p>

<h1 id="1.-Introduction">1. Introduction<a class="anchor-link" href="#1.-Introduction"> </a>
<p>Generative AI and transformer-based large language models (LLMs) have been in the top headlines recently. These models demonstrate impressive performance in question answering, text summarization, code, and text generation. Today, LLMs are being used in real settings by companies, including the heavily-regulated healthcare and life sciences industry (HCLS). The use cases can range from medical information extraction and clinical notes summarization to marketing content generation and medical-legal review automation (MLR process). In this post, we explore how LLMs can be used to design marketing content for disease awareness.</p>
<p>Marketing content is a key component in the communication strategy of HCLS companies.  It’s also a highly non-trivial balance exercise, because the technical content should be as accurate and precise as possible, yet engaging and empowering for the target audience. The main goal of the marketing content is to raise awareness about certain health conditions and disseminate knowledge of possible therapies among patients and healthcare providers. By accessing up-to-date and accurate information, healthcare providers can adapt their patients’ treatment in a more informed and knowledgeable way. However, medical content being highly sensitive, the generation process can be relatively slow (from days to weeks), and may go through numerous peer-review cycles, with thorough regulatory compliance and evaluation protocols.</p>
<p>Could LLMs, with their advanced text generation capabilities, help streamline this process by assisting brand managers and medical experts in their generation and review process?</p>
<p>To answer this question, the AWS Generative AI Innovation Center recently developed an AI assistant for medical content generation. The system is built upon Amazon Bedrock and leverages LLM capabilities to generate curated medical content for disease awareness. With this AI assistant, we can effectively reduce the overall generation time from weeks to hours, while giving the subject matter experts (SMEs) more control over the generation process. This is accomplished through an automated revision functionality, which allows the user to interact and send instructions and comments directly to the LLM via an interactive feedback loop. This is especially important since the revision of content is usually the main bottleneck in the process.</p>
<p>Since every piece of medical information can profoundly impact the well-being of patients, medical content generation comes with additional requirements and hinges upon the content’s accuracy and precision. For this reason, our system has been augmented with additional guardrails for fact-checking and rules evaluation. The goal of these modules is to assess the factuality of the generated text and its alignment with pre-specified rules and regulations. With these additional features, you have more transparency and control over the underlying generative logic of the LLM.</p>
<p>This post walks you through the implementation details and design choices, focusing primarily on the content generation and revision modules. Fact-checking and rules evaluation require special coverage and will be discussed in an upcoming post.</p>

<h1 id="2.-Full Post">2. Full Post<a class="anchor-link" href="#2.-Full Post"> </a>
<p>... <a href="https://aws.amazon.com/blogs/machine-learning/medical-content-creation-in-the-age-of-generative-ai/"> (continue reading here)</a></p>
</h1></h1>]]></content><author><name>Sarah Boufelja Y., Liza Zinovyeva, Nikita Kozodoi et al.</name></author><category term="generative ai" /><category term="natural language processing" /><category term="web app" /><summary type="html"><![CDATA[Automated content generation and revision with LLMs]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://kozodoi.me/images/posts/content.png" /><media:content medium="image" url="https://kozodoi.me/images/posts/content.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Title</title><link href="https://kozodoi.me/2024/02/10/Directional-Forecasting.html" rel="alternate" type="text/html" title="Title" /><published>2024-02-10T00:00:00-06:00</published><updated>2024-02-10T00:00:00-06:00</updated><id>https://kozodoi.me/2024/02/10/Directional-Forecasting</id><content type="html" xml:base="https://kozodoi.me/2024/02/10/Directional-Forecasting.html"><![CDATA[<!--
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: _notebooks/2024-02-10-Directional-Forecasting.ipynb
-->

<div class="container" id="notebook-container">
        
    
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    

    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">train_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;/kaggle/input/directional-forecasting-in-cryptocurrencies/train.csv&#39;</span><span class="p">)</span>
<span class="n">test_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;/kaggle/input/directional-forecasting-in-cryptocurrencies/test.csv&#39;</span><span class="p">)</span>
<span class="n">train_df</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_html rendered_html output_subarea output_execute_result">
<div>
<style scoped="">
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>timestamp</th>
      <th>open</th>
      <th>high</th>
      <th>low</th>
      <th>close</th>
      <th>volume</th>
      <th>quote_asset_volume</th>
      <th>number_of_trades</th>
      <th>taker_buy_base_volume</th>
      <th>taker_buy_quote_volume</th>
      <th>target</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1525471260</td>
      <td>0.90120</td>
      <td>0.90130</td>
      <td>0.90120</td>
      <td>0.90130</td>
      <td>134.98</td>
      <td>121.646459</td>
      <td>4.0</td>
      <td>125.08</td>
      <td>112.723589</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1525471320</td>
      <td>0.90185</td>
      <td>0.90195</td>
      <td>0.90185</td>
      <td>0.90195</td>
      <td>1070.54</td>
      <td>965.505313</td>
      <td>12.0</td>
      <td>879.94</td>
      <td>793.612703</td>
      <td>0.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>1525471380</td>
      <td>0.90140</td>
      <td>0.90140</td>
      <td>0.90139</td>
      <td>0.90139</td>
      <td>2293.06</td>
      <td>2066.963991</td>
      <td>5.0</td>
      <td>0.00</td>
      <td>0.000000</td>
      <td>0.0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>1525471440</td>
      <td>0.90139</td>
      <td>0.90140</td>
      <td>0.90138</td>
      <td>0.90139</td>
      <td>6850.59</td>
      <td>6175.000909</td>
      <td>19.0</td>
      <td>1786.30</td>
      <td>1610.149485</td>
      <td>0.0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>1525471500</td>
      <td>0.90139</td>
      <td>0.90139</td>
      <td>0.90130</td>
      <td>0.90130</td>
      <td>832.30</td>
      <td>750.222624</td>
      <td>3.0</td>
      <td>784.82</td>
      <td>707.428900</td>
      <td>0.0</td>
    </tr>
    <tr>
      <th>...</th>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
      <td>...</td>
    </tr>
    <tr>
      <th>2122433</th>
      <td>1652817240</td>
      <td>0.43060</td>
      <td>0.43060</td>
      <td>0.42990</td>
      <td>0.43040</td>
      <td>136274.00</td>
      <td>58630.162800</td>
      <td>144.0</td>
      <td>54216.00</td>
      <td>23325.927700</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>2122434</th>
      <td>1652817300</td>
      <td>0.43030</td>
      <td>0.43070</td>
      <td>0.43030</td>
      <td>0.43050</td>
      <td>104478.00</td>
      <td>44967.837600</td>
      <td>99.0</td>
      <td>52232.00</td>
      <td>22484.030400</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>2122435</th>
      <td>1652817360</td>
      <td>0.43050</td>
      <td>0.43120</td>
      <td>0.43050</td>
      <td>0.43090</td>
      <td>212396.00</td>
      <td>91526.987200</td>
      <td>177.0</td>
      <td>108324.00</td>
      <td>46673.061600</td>
      <td>0.0</td>
    </tr>
    <tr>
      <th>2122436</th>
      <td>1652817420</td>
      <td>0.43110</td>
      <td>0.43110</td>
      <td>0.43040</td>
      <td>0.43060</td>
      <td>131047.00</td>
      <td>56443.003800</td>
      <td>107.0</td>
      <td>32713.00</td>
      <td>14097.148900</td>
      <td>0.0</td>
    </tr>
    <tr>
      <th>2122437</th>
      <td>1652817480</td>
      <td>0.43060</td>
      <td>0.43080</td>
      <td>0.43010</td>
      <td>0.43010</td>
      <td>101150.00</td>
      <td>43542.262900</td>
      <td>105.0</td>
      <td>46109.00</td>
      <td>19851.723700</td>
      <td>1.0</td>
    </tr>
  </tbody>
</table>
<p>2122438 rows × 11 columns</p>
</div>
</div>

</div>

</div>
</div>

</div>
    

    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="n">sns</span><span class="o">.</span><span class="n">heatmap</span><span class="p">(</span><span class="n">train_df</span><span class="o">.</span><span class="n">corr</span><span class="p">(),</span> <span class="n">annot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;coolwarm&#39;</span><span class="p">,</span> <span class="n">linewidths</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Correlation Heatmap of Features&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_png output_subarea ">
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABjcAAAPkCAYAAADlLGwZAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjcuNSwgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy/xnp5ZAAAACXBIWXMAAA9hAAAPYQGoP6dpAAEAAElEQVR4nOzdeZzN1R/H8fe9s+8bYwazMMMwM7bIvlWkQtJGlCWiIvVTklSopIUiRWlBq1CUKNklaySy77vBmH1fvr8/hss1M0wY183r+Xjcx6N7vuf7vZ/zPc0x8/3cc47JMAxDAAAAAAAAAAAAdsJs6wAAAAAAAAAAAAD+DZIbAAAAAAAAAADArpDcAAAAAAAAAAAAdoXkBgAAAAAAAAAAsCskNwAAAAAAAAAAgF0huQEAAAAAAAAAAOwKyQ0AAAAAAAAAAGBXSG4AAAAAAAAAAAC7QnIDAAAAAAAAAADYFZIbAAAAwBWaMmWKTCaT9u/ff9WuuX//fplMJk2ZMuWqXRPXp9TUVPXu3VtBQUEymUx65plnbB0SAAAAcN0juQEAAIDr0p49e9S3b19VrlxZrq6u8vb2VpMmTTRu3DhlZGTYOryr5ptvvtHYsWNtHYaVHj16yNPTs9jjJpNJ/fv3L9UYJkyYcMMkdt544w1NmTJFTzzxhL788ks98sgjxdYNDw+XyWQq8pWZmVlq8c2ePbtUrg0AAABcLkdbBwAAAABcaO7cuXrggQfk4uKibt26KTY2VtnZ2VqxYoUGDRqkLVu2aNKkSbYO86r45ptv9M8//xT6tn5YWJgyMjLk5ORkm8BsbMKECSpTpox69Ohh61BK3eLFi9WwYUMNGzasRPVr166tZ599tlC5s7Pz1Q5NUkFy4/7779c999xTKtcHAAAALgfJDQAAAFxX9u3bp86dOyssLEyLFy9WcHCw5Vi/fv20e/duzZ0794o/xzAMZWZmys3NrdCxzMxMOTs7y2y23URnk8kkV1dXm30+rp0TJ04oOjq6xPUrVKighx9+uBQjKn35+fnKzs7m/3EAAABcNpalAgAAwHXl7bffVmpqqj777DOrxMZZkZGRevrppy3vc3Nz9dprrykiIkIuLi4KDw/Xiy++qKysLKvzwsPD1a5dO82fP1/16tWTm5ubPv74Yy1dulQmk0nTpk3TSy+9pAoVKsjd3V3JycmSpDVr1uiOO+6Qj4+P3N3d1aJFC/3xxx+XbMePP/6otm3bqnz58nJxcVFERIRee+015eXlWeq0bNlSc+fO1YEDByxLC4WHh0sqfs+NxYsXq1mzZvLw8JCvr686dOigbdu2WdUZPny4TCaTdu/erR49esjX11c+Pj7q2bOn0tPTLxn75cjKytKwYcMUGRkpFxcXhYSE6Pnnny/UD5MnT9att96qwMBAubi4KDo6WhMnTrSqEx4eri1btmjZsmWW+9KyZUtJ5/Y3WbFihQYMGKCyZcvK19dXffv2VXZ2thITE9WtWzf5+fnJz89Pzz//vAzDsLr+6NGj1bhxYwUEBMjNzU1169bVzJkzC7Xp7PJbX3/9taKiouTq6qq6detq+fLlJbonJ06cUK9evVSuXDm5urqqVq1amjp1quX42f/39u3bp7lz51raeqV7tyQmJuqZZ55RSEiIXFxcFBkZqbfeekv5+fn/+j6YTCalpaVp6tSplvjOzqbp0aOH5f/X8539/+/C65y9lzExMXJxcdGvv/4qSTpy5IgeffRRlStXTi4uLoqJidHnn39e6Lrjx49XTEyM3N3d5efnp3r16umbb765gjsFAAAAe8bMDQAAAFxX5syZo8qVK6tx48Ylqt+7d29NnTpV999/v5599lmtWbNGo0aN0rZt2zRr1iyrujt27NBDDz2kvn376rHHHlNUVJTl2GuvvSZnZ2c999xzysrKkrOzsxYvXqw777xTdevW1bBhw2Q2my0P53///XfVr1+/2LimTJkiT09PDRw4UJ6enlq8eLFeeeUVJScn65133pEkDR06VElJSTp8+LDee+89SbroXhcLFy7UnXfeqcqVK2v48OHKyMjQ+PHj1aRJE23YsKHQg+YHH3xQlSpV0qhRo7RhwwZ9+umnCgwM1FtvvVWie3vq1KkS1cvPz9fdd9+tFStWqE+fPqpevbo2b96s9957Tzt37rTar2HixImKiYnR3XffLUdHR82ZM0dPPvmk8vPz1a9fP0nS2LFj9dRTT8nT01NDhw6VJJUrV87qM5966ikFBQVpxIgRWr16tSZNmiRfX1+tXLlSoaGheuONNzRv3jy98847io2NVbdu3Sznjhs3Tnfffbe6du2q7OxsTZs2TQ888IB+/vlntW3b1upzli1bpu+++04DBgyQi4uLJkyYoDvuuENr165VbGxssfckIyNDLVu21O7du9W/f39VqlRJM2bMUI8ePZSYmKinn35a1atX15dffqn//e9/qlixomWpqbJly170fufk5BTqG3d3d7m7uys9PV0tWrTQkSNH1LdvX4WGhmrlypUaMmSIjh07ZrW/S0nuw5dffqnevXurfv366tOnjyQpIiLiovEVZ/HixZo+fbr69++vMmXKKDw8XHFxcWrYsKEl+VG2bFn98ssv6tWrl5KTky3LtX3yyScaMGCA7r//fj399NPKzMzUpk2btGbNGnXp0uWy4gEAAICdMwAAAIDrRFJSkiHJ6NChQ4nqb9y40ZBk9O7d26r8ueeeMyQZixcvtpSFhYUZkoxff/3Vqu6SJUsMSUblypWN9PR0S3l+fr5RpUoVo02bNkZ+fr6lPD093ahUqZLRunVrS9nkyZMNSca+ffus6l2ob9++hru7u5GZmWkpa9u2rREWFlao7r59+wxJxuTJky1ltWvXNgIDA434+HhL2d9//22YzWajW7dulrJhw4YZkoxHH33U6podO3Y0AgICCn3Whbp3725IuuirX79+lvpffvmlYTabjd9//93qOh999JEhyfjjjz8uel/atGljVK5c2aosJibGaNGiRaG6Z+/1hf3SqFEjw2QyGY8//rilLDc316hYsWKh61wYQ3Z2thEbG2vceuutVuVn2/rnn39ayg4cOGC4uroaHTt2LBTb+caOHWtIMr766iurz2nUqJHh6elpJCcnW8rDwsKMtm3bXvR659ctqj+GDRtmGIZhvPbaa4aHh4exc+dOq/NeeOEFw8HBwTh48OC/vg8eHh5G9+7dC8XSvXv3Iv/fPfv/3/kkGWaz2diyZYtVea9evYzg4GDj1KlTVuWdO3c2fHx8LDF26NDBiImJKXxDAAAAcMNiWSoAAABcN84uBeXl5VWi+vPmzZMkDRw40Kr87DfgL9ybo1KlSmrTpk2R1+revbvV/hsbN27Url271KVLF8XHx+vUqVM6deqU0tLSdNttt2n58uWFlvk53/nXSklJ0alTp9SsWTOlp6dr+/btJWrf+Y4dO6aNGzeqR48e8vf3t5TXrFlTrVu3ttyL8z3++ONW75s1a6b4+HjLfb4YV1dXLViwoMjXhWbMmKHq1aurWrVqlvt06tQp3XrrrZKkJUuWWOqef1+SkpJ06tQptWjRQnv37lVSUtKlb8QZvXr1slr6qEGDBjIMQ7169bKUOTg4qF69etq7d6/VuefHkJCQoKSkJDVr1kwbNmwo9DmNGjVS3bp1Le9DQ0PVoUMHzZ8/32qJsQvNmzdPQUFBeuihhyxlTk5OGjBggFJTU7Vs2bISt/VCDRo0KNQnZ2emzJgxQ82aNZOfn59VX7Rq1Up5eXlWS2r9m/twNbRo0cJqbxHDMPT999+rffv2MgzDKt42bdooKSnJEouvr68OHz6sdevWlUpsAAAAsD8sSwUAAIDrhre3t6SCZEBJHDhwQGazWZGRkVblQUFB8vX11YEDB6zKK1WqVOy1Ljy2a9cuSQVJj+IkJSXJz8+vyGNbtmzRSy+9pMWLFxdKJvybh/hnnW3L+UtpnVW9enXNnz9faWlp8vDwsJSHhoZa1Tsba0JCguVeF8fBwUGtWrUqUWy7du3Stm3bil1O6cSJE5b//uOPPzRs2DCtWrWq0P4fSUlJ8vHxKdFnXti2s+eFhIQUKk9ISLAq+/nnn/X6669r48aNVnuCXLhPhCRVqVKlUFnVqlWVnp6ukydPKigoqMj4Dhw4oCpVqhTalL569eqW45erTJkyxfbNrl27tGnTphL1xb+5D1fDhT9jJ0+eVGJioiZNmqRJkyZdNN7Bgwdr4cKFql+/viIjI3X77berS5cuatKkSanECgAAgOsfyQ0AAABcN7y9vVW+fHn9888//+q8kj6MPf+b6pc6dnZWxjvvvKPatWsXeU5x+2MkJiaqRYsW8vb21quvvqqIiAi5urpqw4YNGjx48EVnfFxNDg4ORZYbF2ywfaXy8/NVo0YNvfvuu0UeP5tw2LNnj2677TZVq1ZN7777rkJCQuTs7Kx58+bpvffe+1f3pbi2FVV+fnt///133X333WrevLkmTJig4OBgOTk5afLkyf+Jzanz8/PVunVrPf/880Uer1q1qqSrcx+K+7krbkZLcT9jDz/8cLFJxJo1a0oqSArt2LFDP//8s3799Vd9//33mjBhgl555RWNGDGiRPECAADgv4XkBgAAAK4r7dq106RJk7Rq1So1atToonXDwsKUn5+vXbt2Wb4RL0lxcXFKTExUWFjYZcdxdtNkb2/vEs9gOGvp0qWKj4/XDz/8oObNm1vK9+3bV6huSRMzZ9uyY8eOQse2b9+uMmXKWM3auJYiIiL0999/67bbbrtoe+bMmaOsrCz99NNPVjMvzl+26qzSmj3w/fffy9XVVfPnz5eLi4ulfPLkyUXWPzuD53w7d+6Uu7v7RTf+DgsL06ZNm5Sfn281e+PskmRX8v/mxURERCg1NfWS/8/+m/tQXF/4+fkpMTGxUHlJZ6WULVtWXl5eysvLK9HPmIeHhzp16qROnTopOztb9957r0aOHKkhQ4bI1dW1RJ8JAACA/w723AAAAMB15fnnn5eHh4d69+6tuLi4Qsf37NmjcePGSZLuuusuSdLYsWOt6pydQdC2bdvLjqNu3bqKiIjQ6NGjlZqaWuj4yZMniz337OyB82cMZGdna8KECYXqenh4lGiZquDgYNWuXVtTp061eqD8zz//6LfffrPcC1t48MEHdeTIEX3yySeFjmVkZCgtLU1S0fclKSmpyAfqHh4eRT44v1IODg4ymUxWswv279+v2bNnF1l/1apVVntQHDp0SD/++KNuv/32YmePSAX/bx4/flzfffedpSw3N1fjx4+Xp6enWrRoceWNKcKDDz6oVatWaf78+YWOJSYmKjc3V9K/uw/F9UVERISSkpK0adMmS9mxY8c0a9asEsXq4OCg++67T99//32Rs7XO/xmLj4+3Oubs7Kzo6GgZhqGcnJwSfR4AAAD+W5i5AQAAgOtKRESEvvnmG3Xq1EnVq1dXt27dFBsbq+zsbK1cuVIzZsxQjx49JEm1atVS9+7dNWnSJMtSUGvXrtXUqVN1zz336JZbbrnsOMxmsz799FPdeeediomJUc+ePVWhQgUdOXJES5Yskbe3t+bMmVPkuY0bN5afn5+6d++uAQMGyGQy6csvvyxyOai6devqu+++08CBA3XzzTfL09NT7du3L/K677zzju688041atRIvXr1UkZGhsaPHy8fHx8NHz78stt6pR555BFNnz5djz/+uJYsWaImTZooLy9P27dv1/Tp0zV//nzVq1dPt99+u5ydndW+fXv17dtXqamp+uSTTxQYGKhjx45ZXbNu3bqaOHGiXn/9dUVGRiowMNCyQfmVaNu2rd59913dcccd6tKli06cOKEPP/xQkZGRVg/pz4qNjVWbNm00YMAAubi4WBJUl1oKqU+fPvr444/Vo0cPrV+/XuHh4Zo5c6b++OMPjR07Vl5eXlfclqIMGjRIP/30k9q1a6cePXqobt26SktL0+bNmzVz5kzt379fZcqU+Vf3oW7d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pk2bavPmzfL29i68ZrVatW7dOn366af6/vvvDSUEAACguAEAAADABj377LNav369fH19FR0drb59+yo8PNx0LNwBClT2y8nJSRaLRdLNtio/V6VKFU2fPl0DBw6839FwB3gG7Rv7BwAlczIdAMC9ceLECb399tuKjo7W+fPnJUlr167VwYMHDScDAAAo2YoVK5SRkaExY8Zo9+7dioiI0IMPPqgJEybwtriduHDhgqKiohQYGKhRo0YpOTnZdCSUUlpamk6cOKGCggLt3r1baWlphT9nzpxRVlYWhQ07wDNo39g/ACgZJzcAB7RlyxY9/fTTat26tbZu3arDhw8rJCREEydO1J49exQfH286IgAAwB05ffq0Fi9erHnz5ik1NVV5eXmmI6EULl++rL/97W/6y1/+om+++UZhYWHq27ev+vTpo9q1a5uOhzLy29/+VnPmzFHNmjVNR8HP8AzaN/YPAG6P4gbggFq2bKmePXsqNjZW7u7uSklJUUhIiHbv3q1u3brp9OnTpiMCAACUWm5urlavXq0///nPWr16tby9vXXmzBnTsXCHKFA5rv/+NwdsF8+gfWP/AKA42lIBDmj//v3q2rVrsXU/Pz9dvHjRQCIAAIA7l5CQoJdeeknVq1fXCy+8IA8PD61atYoXNexQbm6u9uzZo8TERH3//feqXr266UhAucIzaN/YPwC4NYobgAPy8vJSRkZGsfWkpCQFBAQYSAQAAHBnAgIC1KlTJ128eFGzZ8/WDz/8oHnz5unJJ58sHHQM20eBCjCLZ9C+sX8AcHsVTAcAUPaef/55jR49Wn/7299ksViUn5+v7du3a+TIkRowYIDpeAAAACV699131bNnT3l5eZmOgrsUEBCgzMxMRUVFafbs2ercubMqVapkOhZQbvAM2jf2DwBKxswNwAHduHFDr776qhYsWCCr1aoKFSrIarWqT58+WrBggZydnU1HBAAAgIP77LPPSlWgOn36tPz9/eXkRGMBe8XMDdvEM2jf2D8AKBnFDcCBpaen68CBA8rOzlazZs0UGhpqOhIAAABQhIeHh5KTk/li3I5R3LBvPIP2jf0DUJ5R1gUcWFBQkDp16qRevXpR2AAAAIBN4n072xIREaHLly9LksaPH6+cnJwS/5s//OEP8vb2vtfRcI/wDNo39g9AecbJDcABFRQUKD4+XgkJCTp/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" />
</div>

</div>

</div>
</div>

</div>
    

    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">correlation_matrix</span> <span class="o">=</span> <span class="n">train_df</span><span class="o">.</span><span class="n">corr</span><span class="p">()</span>

<span class="n">signal_corr</span> <span class="o">=</span> <span class="n">correlation_matrix</span><span class="p">[[</span><span class="s1">&#39;target&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="s1">&#39;target&#39;</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">))</span>
<span class="n">sns</span><span class="o">.</span><span class="n">heatmap</span><span class="p">(</span><span class="n">signal_corr</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">annot</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;coolwarm&#39;</span><span class="p">,</span> <span class="n">cbar</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Correlation of Features with &#39;target&#39;&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_png output_subarea ">
<img src="data:image/png;base64,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" />
</div>

</div>

</div>
</div>

</div>
    

    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">timezone</span>

<span class="n">train_df</span><span class="p">[</span><span class="s1">&#39;timestamp&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">train_df</span><span class="p">[</span><span class="s1">&#39;timestamp&#39;</span><span class="p">],</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;s&#39;</span><span class="p">)</span>
<span class="n">train_df</span><span class="p">[</span><span class="s1">&#39;minute&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">train_df</span><span class="p">[</span><span class="s1">&#39;timestamp&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">minute</span>
<span class="n">train_df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;timestamp&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="n">test_df</span><span class="p">[</span><span class="s1">&#39;timestamp&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">test_df</span><span class="p">[</span><span class="s1">&#39;timestamp&#39;</span><span class="p">],</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;s&#39;</span><span class="p">)</span>
<span class="n">test_df</span><span class="p">[</span><span class="s1">&#39;minute&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">test_df</span><span class="p">[</span><span class="s1">&#39;timestamp&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">minute</span>
<span class="n">test_df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;timestamp&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#USING Z-SCORE METHOD TO GET RID OF OUTLIERS</span>

<span class="n">z_threshold</span> <span class="o">=</span> <span class="mi">3</span>

<span class="n">z_scores</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">((</span><span class="n">train_df</span> <span class="o">-</span> <span class="n">train_df</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span> <span class="o">/</span> <span class="n">train_df</span><span class="o">.</span><span class="n">std</span><span class="p">())</span>

<span class="n">outliers</span> <span class="o">=</span> <span class="p">(</span><span class="n">z_scores</span> <span class="o">&gt;</span> <span class="n">z_threshold</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Outliers:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">train_df</span><span class="p">[</span><span class="n">outliers</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)])</span>

<span class="n">train_df</span> <span class="o">=</span> <span class="n">train_df</span><span class="p">[</span><span class="o">~</span><span class="n">outliers</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Outliers:
             open     high      low    close      volume  quote_asset_volume  \
107836   0.50566  0.50631  0.48507  0.50008   1822170.0        9.088897e+05   
108201   0.47580  0.47615  0.47500  0.47500   1145163.6        5.439815e+05   
197296   0.31937  0.32362  0.31937  0.32278   1811583.1        5.802121e+05   
199657   0.36803  0.37200  0.36778  0.37152   1346806.7        4.980468e+05   
200189   0.48499  0.49021  0.48356  0.49000   2875628.5        1.396135e+06   
...          ...      ...      ...      ...         ...                 ...   
2120984  0.42000  0.42800  0.41990  0.42790   2374477.0        1.006244e+06   
2120985  0.42790  0.44260  0.42790  0.43930  12363632.0        5.401453e+06   
2120986  0.43940  0.43940  0.43300  0.43450   3054547.0        1.332590e+06   
2120987  0.43450  0.43600  0.42480  0.42650   6367198.0        2.730539e+06   
2120988  0.42650  0.42750  0.42270  0.42270   2871307.0        1.220657e+06   

         number_of_trades  taker_buy_base_volume  taker_buy_quote_volume  \
107836              865.0              1151145.0            5.747437e+05   
108201               42.0              1107813.4            5.262225e+05   
197296              261.0              1675449.4            5.364960e+05   
199657              459.0              1186219.9            4.387031e+05   
200189              728.0              2623470.3            1.273743e+06   
...                   ...                    ...                     ...   
2120984            1285.0              1749782.0            7.408540e+05   
2120985            7547.0              6577021.0            2.870867e+06   
2120986            2296.0              1430104.0            6.235863e+05   
2120987            3992.0              2906838.0            1.246762e+06   
2120988            1939.0              1315831.0            5.595667e+05   

         target  minute  
107836      0.0      17  
108201      1.0      22  
197296      0.0      17  
199657      0.0      38  
200189      0.0      30  
...         ...     ...  
2120984     1.0      45  
2120985     0.0      46  
2120986     0.0      47  
2120987     0.0      48  
2120988     1.0      49  

[74452 rows x 11 columns]
</pre>
</div>
</div>

</div>
</div>

</div>
    

    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">train_df</span><span class="p">[</span><span class="s1">&#39;close_shift_1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">train_df</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)[</span><span class="s1">&#39;close&#39;</span><span class="p">]</span>
<span class="n">train_df</span><span class="p">[</span><span class="s1">&#39;close_shift_2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">train_df</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)[</span><span class="s1">&#39;close&#39;</span><span class="p">]</span>
<span class="n">train_df</span><span class="p">[</span><span class="s1">&#39;close_shift_3&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">train_df</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">)[</span><span class="s1">&#39;close&#39;</span><span class="p">]</span>
<span class="n">train_df</span><span class="p">[</span><span class="s1">&#39;close_shift_4&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">train_df</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">)[</span><span class="s1">&#39;close&#39;</span><span class="p">]</span>
<span class="n">train_df</span><span class="p">[</span><span class="s1">&#39;close_shift_5&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">train_df</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">)[</span><span class="s1">&#39;close&#39;</span><span class="p">]</span>


<span class="n">test_df</span><span class="p">[</span><span class="s1">&#39;close_shift_1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">test_df</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)[</span><span class="s1">&#39;close&#39;</span><span class="p">]</span>
<span class="n">test_df</span><span class="p">[</span><span class="s1">&#39;close_shift_2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">test_df</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)[</span><span class="s1">&#39;close&#39;</span><span class="p">]</span>
<span class="n">test_df</span><span class="p">[</span><span class="s1">&#39;close_shift_3&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">test_df</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">)[</span><span class="s1">&#39;close&#39;</span><span class="p">]</span>
<span class="n">test_df</span><span class="p">[</span><span class="s1">&#39;close_shift_4&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">test_df</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">)[</span><span class="s1">&#39;close&#39;</span><span class="p">]</span>
<span class="n">test_df</span><span class="p">[</span><span class="s1">&#39;close_shift_5&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">test_df</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">)[</span><span class="s1">&#39;close&#39;</span><span class="p">]</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stderr output_text">
<pre>/tmp/ipykernel_18/3596558217.py:1: SettingWithCopyWarning: 
A value is trying to be set on a copy of a slice from a DataFrame.
Try using .loc[row_indexer,col_indexer] = value instead

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy
  train_df[&#39;close_shift_1&#39;] = train_df.shift(-1)[&#39;close&#39;]
/tmp/ipykernel_18/3596558217.py:2: SettingWithCopyWarning: 
A value is trying to be set on a copy of a slice from a DataFrame.
Try using .loc[row_indexer,col_indexer] = value instead

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy
  train_df[&#39;close_shift_2&#39;] = train_df.shift(-2)[&#39;close&#39;]
/tmp/ipykernel_18/3596558217.py:3: SettingWithCopyWarning: 
A value is trying to be set on a copy of a slice from a DataFrame.
Try using .loc[row_indexer,col_indexer] = value instead

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy
  train_df[&#39;close_shift_3&#39;] = train_df.shift(-3)[&#39;close&#39;]
/tmp/ipykernel_18/3596558217.py:4: SettingWithCopyWarning: 
A value is trying to be set on a copy of a slice from a DataFrame.
Try using .loc[row_indexer,col_indexer] = value instead

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy
  train_df[&#39;close_shift_4&#39;] = train_df.shift(-4)[&#39;close&#39;]
/tmp/ipykernel_18/3596558217.py:5: SettingWithCopyWarning: 
A value is trying to be set on a copy of a slice from a DataFrame.
Try using .loc[row_indexer,col_indexer] = value instead

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy
  train_df[&#39;close_shift_5&#39;] = train_df.shift(-5)[&#39;close&#39;]
</pre>
</div>
</div>

</div>
</div>

</div>
    

    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">Feature_Engineering</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
    <span class="n">train_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

    
<span class="c1">#   train_df[&#39;true_range&#39;] = train_df[[&#39;high&#39;, &#39;low&#39;, &#39;close&#39;]].max(axis=1) - train_df[[&#39;high&#39;, &#39;low&#39;, &#39;close&#39;]].min(axis=1)    --&gt;BAD INDICATORS</span>
<span class="c1">#   train_df[&#39;atr&#39;] = (train_df[[&#39;high&#39;, &#39;low&#39;, &#39;close&#39;]].max(axis=1) - train_df[[&#39;high&#39;, &#39;low&#39;, &#39;close&#39;]].min(axis=1)).rolling(window=14).mean()     --&gt;BAD INDICATOR</span>
    
    <span class="n">train_df</span><span class="p">[</span><span class="s1">&#39;sma_5&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">train_df</span><span class="p">[</span><span class="s1">&#39;close&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="n">window</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="n">train_df</span><span class="p">[</span><span class="s1">&#39;sma_10&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">train_df</span><span class="p">[</span><span class="s1">&#39;close&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="n">window</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="n">train_df</span><span class="p">[</span><span class="s1">&#39;sma_shift_5&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">train_df</span><span class="p">[</span><span class="s1">&#39;close_shift_1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="n">window</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="n">train_df</span><span class="p">[</span><span class="s1">&#39;sma_shiftmedian_5&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">train_df</span><span class="p">[</span><span class="s1">&#39;close_shift_1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="n">window</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">median</span><span class="p">()</span>
    <span class="n">train_df</span><span class="p">[</span><span class="s1">&#39;sma_shiftmedian_10&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">train_df</span><span class="p">[</span><span class="s1">&#39;close_shift_1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="n">window</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">median</span><span class="p">()</span>

    
    <span class="n">train_df</span><span class="p">[</span><span class="s1">&#39;sma_20&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">train_df</span><span class="p">[</span><span class="s1">&#39;close&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="n">window</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

    <span class="n">train_df</span><span class="p">[</span><span class="s1">&#39;bb_up&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">train_df</span><span class="p">[</span><span class="s1">&#39;sma_20&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="p">((</span><span class="n">train_df</span><span class="p">[</span><span class="s1">&#39;close&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="n">window</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span><span class="o">.</span><span class="n">std</span><span class="p">())</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">train_df</span><span class="p">[</span><span class="s1">&#39;bb_low&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">train_df</span><span class="p">[</span><span class="s1">&#39;sma_20&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="p">((</span><span class="n">train_df</span><span class="p">[</span><span class="s1">&#39;close&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="n">window</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span><span class="o">.</span><span class="n">std</span><span class="p">())</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
    
    <span class="n">train_df</span><span class="p">[</span><span class="s1">&#39;ema_5&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">train_df</span><span class="p">[</span><span class="s1">&#39;close&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">ewm</span><span class="p">(</span><span class="n">span</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">adjust</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="n">train_df</span><span class="p">[</span><span class="s1">&#39;ema_10&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">train_df</span><span class="p">[</span><span class="s1">&#39;close&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">ewm</span><span class="p">(</span><span class="n">span</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">adjust</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="n">train_df</span><span class="p">[</span><span class="s1">&#39;ema_shift_5&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">train_df</span><span class="p">[</span><span class="s1">&#39;close_shift_1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">ewm</span><span class="p">(</span><span class="n">span</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">adjust</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="n">train_df</span><span class="p">[</span><span class="s1">&#39;ema_crossover&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">train_df</span><span class="p">[</span><span class="s1">&#39;ema_5&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">train_df</span><span class="p">[</span><span class="s1">&#39;ema_10&#39;</span><span class="p">]</span>
    <span class="n">train_df</span><span class="p">[</span><span class="s1">&#39;close_diff&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">train_df</span><span class="p">[</span><span class="s1">&#39;close&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">train_df</span><span class="p">[</span><span class="s1">&#39;close_shift_1&#39;</span><span class="p">]</span>
    <span class="n">train_df</span><span class="p">[</span><span class="s1">&#39;close_shift_1_volatility&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">train_df</span><span class="p">[</span><span class="s1">&#39;close_shift_1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="n">window</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">std</span><span class="p">()</span>
    
    <span class="n">train_df</span><span class="p">[</span><span class="s1">&#39;close_shift_1_ma20&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">train_df</span><span class="p">[</span><span class="s1">&#39;close_shift_1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="n">window</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="n">train_df</span><span class="p">[</span><span class="s1">&#39;close_shift_1_upper_bb&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">train_df</span><span class="p">[</span><span class="s1">&#39;close_shift_1_ma20&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">train_df</span><span class="p">[</span><span class="s1">&#39;close_shift_1_volatility&#39;</span><span class="p">]</span>
    <span class="n">train_df</span><span class="p">[</span><span class="s1">&#39;close_shift_1_lower_bb&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">train_df</span><span class="p">[</span><span class="s1">&#39;close_shift_1_ma20&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">train_df</span><span class="p">[</span><span class="s1">&#39;close_shift_1_volatility&#39;</span><span class="p">]</span>
    <span class="n">train_df</span><span class="p">[</span><span class="s1">&#39;close_momentum_5&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">train_df</span><span class="p">[</span><span class="s1">&#39;close&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">train_df</span><span class="p">[</span><span class="s1">&#39;close&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
    <span class="n">train_df</span><span class="p">[</span><span class="s1">&#39;close_to_shift_ratio&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">train_df</span><span class="p">[</span><span class="s1">&#39;close&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">train_df</span><span class="p">[</span><span class="s1">&#39;close_shift_1&#39;</span><span class="p">]</span>

    
    <span class="k">return</span> <span class="n">train_df</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">train_df</span> <span class="o">=</span> <span class="n">Feature_Engineering</span><span class="p">(</span><span class="n">train_df</span><span class="p">)</span>
<span class="n">test_df</span> <span class="o">=</span> <span class="n">Feature_Engineering</span><span class="p">(</span><span class="n">test_df</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">train_df</span> <span class="o">=</span> <span class="n">train_df</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">train_df</span><span class="o">.</span><span class="n">columns</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>Index([&#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39;, &#39;quote_asset_volume&#39;,
       &#39;number_of_trades&#39;, &#39;taker_buy_base_volume&#39;, &#39;taker_buy_quote_volume&#39;,
       &#39;target&#39;, &#39;minute&#39;, &#39;close_shift_1&#39;, &#39;close_shift_2&#39;, &#39;close_shift_3&#39;,
       &#39;close_shift_4&#39;, &#39;close_shift_5&#39;, &#39;sma_5&#39;, &#39;sma_10&#39;, &#39;sma_shift_5&#39;,
       &#39;sma_shiftmedian_5&#39;, &#39;sma_shiftmedian_10&#39;, &#39;sma_20&#39;, &#39;bb_up&#39;, &#39;bb_low&#39;,
       &#39;ema_5&#39;, &#39;ema_10&#39;, &#39;ema_shift_5&#39;, &#39;ema_crossover&#39;, &#39;close_diff&#39;,
       &#39;close_shift_1_volatility&#39;, &#39;close_shift_1_ma20&#39;,
       &#39;close_shift_1_upper_bb&#39;, &#39;close_shift_1_lower_bb&#39;, &#39;close_momentum_5&#39;,
       &#39;close_to_shift_ratio&#39;],
      dtype=&#39;object&#39;)</pre>
</div>

</div>

</div>
</div>

</div>
    

    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>

<span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">train_df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]),</span> <span class="n">train_df</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span>
<span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span> <span class="n">stratify</span><span class="o">=</span><span class="n">y</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">MinMaxScaler</span>

<span class="n">scaler</span> <span class="o">=</span> <span class="n">MinMaxScaler</span><span class="p">()</span>
<span class="n">X_train_scaled</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X_train</span><span class="p">)</span>
<span class="n">X_test_scaled</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.ensemble</span> <span class="kn">import</span> <span class="n">RandomForestClassifier</span>

<span class="n">model</span> <span class="o">=</span> <span class="n">RandomForestClassifier</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span> <span class="n">n_estimators</span><span class="o">=</span><span class="mi">110</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_depth</span><span class="o">=</span><span class="mi">40</span><span class="p">)</span>
<span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train_scaled</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stderr output_text">
<pre>[Parallel(n_jobs=-1)]: Using backend ThreadingBackend with 4 concurrent workers.
</pre>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>building tree 1 of 110
building tree 2 of 110
building tree 3 of 110
building tree 4 of 110
building tree 5 of 110
building tree 6 of 110
building tree 7 of 110
building tree 8 of 110
building tree 9 of 110
building tree 10 of 110
building tree 11 of 110
building tree 12 of 110
building tree 13 of 110
building tree 14 of 110
building tree 15 of 110
building tree 16 of 110
building tree 17 of 110
building tree 18 of 110
building tree 19 of 110
building tree 20 of 110
building tree 21 of 110
building tree 22 of 110
building tree 23 of 110
building tree 24 of 110
building tree 25 of 110
building tree 26 of 110
building tree 27 of 110
building tree 28 of 110
building tree 29 of 110
building tree 30 of 110
building tree 31 of 110
building tree 32 of 110
building tree 33 of 110
building tree 34 of 110
building tree 35 of 110
building tree 36 of 110
building tree 37 of 110
</pre>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stderr output_text">
<pre>[Parallel(n_jobs=-1)]: Done  33 tasks      | elapsed:  4.0min
</pre>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>building tree 38 of 110
building tree 39 of 110
building tree 40 of 110
building tree 41 of 110
building tree 42 of 110
building tree 43 of 110
building tree 44 of 110
building tree 45 of 110
building tree 46 of 110
building tree 47 of 110
building tree 48 of 110
building tree 49 of 110
building tree 50 of 110
building tree 51 of 110
building tree 52 of 110
building tree 53 of 110
building tree 54 of 110
building tree 55 of 110
building tree 56 of 110
building tree 57 of 110
building tree 58 of 110
building tree 59 of 110
building tree 60 of 110
building tree 61 of 110
building tree 62 of 110
building tree 63 of 110
building tree 64 of 110
building tree 65 of 110
building tree 66 of 110
building tree 67 of 110
building tree 68 of 110
building tree 69 of 110
building tree 70 of 110
building tree 71 of 110
building tree 72 of 110
building tree 73 of 110
building tree 74 of 110
building tree 75 of 110
building tree 76 of 110
building tree 77 of 110
building tree 78 of 110
building tree 79 of 110
building tree 80 of 110
building tree 81 of 110
building tree 82 of 110
building tree 83 of 110
building tree 84 of 110
building tree 85 of 110
building tree 86 of 110
building tree 87 of 110
building tree 88 of 110
building tree 89 of 110
building tree 90 of 110
building tree 91 of 110
building tree 92 of 110
building tree 93 of 110
building tree 94 of 110
building tree 95 of 110
building tree 96 of 110
building tree 97 of 110
building tree 98 of 110
building tree 99 of 110
building tree 100 of 110
building tree 101 of 110
building tree 102 of 110
building tree 103 of 110
building tree 104 of 110
building tree 105 of 110
building tree 106 of 110
building tree 107 of 110
building tree 108 of 110
building tree 109 of 110
building tree 110 of 110
</pre>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stderr output_text">
<pre>[Parallel(n_jobs=-1)]: Done 110 out of 110 | elapsed: 12.7min finished
</pre>
</div>
</div>

<div class="output_area">


<div class="output_html rendered_html output_subarea output_execute_result">
<style>#sk-container-id-1 {color: black;background-color: white;}#sk-container-id-1 pre{padding: 0;}#sk-container-id-1 div.sk-toggleable {background-color: white;}#sk-container-id-1 label.sk-toggleable__label {cursor: pointer;display: block;width: 100%;margin-bottom: 0;padding: 0.3em;box-sizing: border-box;text-align: center;}#sk-container-id-1 label.sk-toggleable__label-arrow:before {content: "▸";float: left;margin-right: 0.25em;color: #696969;}#sk-container-id-1 label.sk-toggleable__label-arrow:hover:before {color: black;}#sk-container-id-1 div.sk-estimator:hover label.sk-toggleable__label-arrow:before {color: black;}#sk-container-id-1 div.sk-toggleable__content {max-height: 0;max-width: 0;overflow: hidden;text-align: left;background-color: #f0f8ff;}#sk-container-id-1 div.sk-toggleable__content pre {margin: 0.2em;color: black;border-radius: 0.25em;background-color: #f0f8ff;}#sk-container-id-1 input.sk-toggleable__control:checked~div.sk-toggleable__content {max-height: 200px;max-width: 100%;overflow: auto;}#sk-container-id-1 input.sk-toggleable__control:checked~label.sk-toggleable__label-arrow:before {content: "▾";}#sk-container-id-1 div.sk-estimator input.sk-toggleable__control:checked~label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-1 div.sk-label input.sk-toggleable__control:checked~label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-1 input.sk-hidden--visually {border: 0;clip: rect(1px 1px 1px 1px);clip: rect(1px, 1px, 1px, 1px);height: 1px;margin: -1px;overflow: hidden;padding: 0;position: absolute;width: 1px;}#sk-container-id-1 div.sk-estimator {font-family: monospace;background-color: #f0f8ff;border: 1px dotted black;border-radius: 0.25em;box-sizing: border-box;margin-bottom: 0.5em;}#sk-container-id-1 div.sk-estimator:hover {background-color: #d4ebff;}#sk-container-id-1 div.sk-parallel-item::after {content: "";width: 100%;border-bottom: 1px solid gray;flex-grow: 1;}#sk-container-id-1 div.sk-label:hover label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-1 div.sk-serial::before {content: "";position: absolute;border-left: 1px solid gray;box-sizing: border-box;top: 0;bottom: 0;left: 50%;z-index: 0;}#sk-container-id-1 div.sk-serial {display: flex;flex-direction: column;align-items: center;background-color: white;padding-right: 0.2em;padding-left: 0.2em;position: relative;}#sk-container-id-1 div.sk-item {position: relative;z-index: 1;}#sk-container-id-1 div.sk-parallel {display: flex;align-items: stretch;justify-content: center;background-color: white;position: relative;}#sk-container-id-1 div.sk-item::before, #sk-container-id-1 div.sk-parallel-item::before {content: "";position: absolute;border-left: 1px solid gray;box-sizing: border-box;top: 0;bottom: 0;left: 50%;z-index: -1;}#sk-container-id-1 div.sk-parallel-item {display: flex;flex-direction: column;z-index: 1;position: relative;background-color: white;}#sk-container-id-1 div.sk-parallel-item:first-child::after {align-self: flex-end;width: 50%;}#sk-container-id-1 div.sk-parallel-item:last-child::after {align-self: flex-start;width: 50%;}#sk-container-id-1 div.sk-parallel-item:only-child::after {width: 0;}#sk-container-id-1 div.sk-dashed-wrapped {border: 1px dashed gray;margin: 0 0.4em 0.5em 0.4em;box-sizing: border-box;padding-bottom: 0.4em;background-color: white;}#sk-container-id-1 div.sk-label label {font-family: monospace;font-weight: bold;display: inline-block;line-height: 1.2em;}#sk-container-id-1 div.sk-label-container {text-align: center;}#sk-container-id-1 div.sk-container {/* jupyter's `normalize.less` sets `[hidden] { display: none; }` but bootstrap.min.css set `[hidden] { display: none !important; }` so we also need the `!important` here to be able to override the default hidden behavior on the sphinx rendered scikit-learn.org. See: https://github.com/scikit-learn/scikit-learn/issues/21755 */display: inline-block !important;position: relative;}#sk-container-id-1 div.sk-text-repr-fallback {display: none;}</style><div id="sk-container-id-1" class="sk-top-container"><div class="sk-text-repr-fallback"><pre>RandomForestClassifier(max_depth=40, n_estimators=110, n_jobs=-1,
                       random_state=42, verbose=2)</pre><b>In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. <br />On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.</b></div><div class="sk-container" hidden=""><div class="sk-item"><div class="sk-estimator sk-toggleable"><input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-1" type="checkbox" checked="" /><label for="sk-estimator-id-1" class="sk-toggleable__label sk-toggleable__label-arrow">RandomForestClassifier</label><div class="sk-toggleable__content"><pre>RandomForestClassifier(max_depth=40, n_estimators=110, n_jobs=-1,
                       random_state=42, verbose=2)</pre></div></div></div></div></div>
</div>

</div>

</div>
</div>

</div>
    

    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">y_predictions</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test_scaled</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stderr output_text">
<pre>[Parallel(n_jobs=4)]: Using backend ThreadingBackend with 4 concurrent workers.
[Parallel(n_jobs=4)]: Done  33 tasks      | elapsed:    0.9s
[Parallel(n_jobs=4)]: Done 110 out of 110 | elapsed:    2.7s finished
</pre>
</div>
</div>

</div>
</div>

</div>
    

    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">accuracy_score</span><span class="p">,</span> <span class="n">classification_report</span>

<span class="nb">print</span><span class="p">(</span><span class="n">accuracy_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_predictions</span><span class="p">))</span>

<span class="nb">print</span><span class="p">(</span><span class="n">classification_report</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_predictions</span><span class="p">))</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>0.9983227252418865
              precision    recall  f1-score   support

         0.0       1.00      1.00      1.00    215042
         1.0       1.00      1.00      1.00    194551

    accuracy                           1.00    409593
   macro avg       1.00      1.00      1.00    409593
weighted avg       1.00      1.00      1.00    409593

</pre>
</div>
</div>

</div>
</div>

</div>
    

    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">importance_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
    <span class="s1">&#39;feature&#39;</span><span class="p">:</span> <span class="n">X_train</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span>
    <span class="s1">&#39;importance&#39;</span><span class="p">:</span> <span class="n">model</span><span class="o">.</span><span class="n">feature_importances_</span>
<span class="p">})</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s1">&#39;importance&#39;</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="n">importance_df</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_html rendered_html output_subarea output_execute_result">
<div>
<style scoped="">
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>feature</th>
      <th>importance</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>27</th>
      <td>close_diff</td>
      <td>0.536047</td>
    </tr>
    <tr>
      <th>33</th>
      <td>close_to_shift_ratio</td>
      <td>0.454401</td>
    </tr>
    <tr>
      <th>28</th>
      <td>close_shift_1_volatility</td>
      <td>0.000878</td>
    </tr>
    <tr>
      <th>32</th>
      <td>close_momentum_5</td>
      <td>0.000794</td>
    </tr>
    <tr>
      <th>26</th>
      <td>ema_crossover</td>
      <td>0.000621</td>
    </tr>
    <tr>
      <th>6</th>
      <td>number_of_trades</td>
      <td>0.000494</td>
    </tr>
    <tr>
      <th>4</th>
      <td>volume</td>
      <td>0.000389</td>
    </tr>
    <tr>
      <th>5</th>
      <td>quote_asset_volume</td>
      <td>0.000388</td>
    </tr>
    <tr>
      <th>8</th>
      <td>taker_buy_quote_volume</td>
      <td>0.000362</td>
    </tr>
    <tr>
      <th>7</th>
      <td>taker_buy_base_volume</td>
      <td>0.000345</td>
    </tr>
    <tr>
      <th>10</th>
      <td>close_shift_1</td>
      <td>0.000315</td>
    </tr>
    <tr>
      <th>3</th>
      <td>close</td>
      <td>0.000279</td>
    </tr>
    <tr>
      <th>11</th>
      <td>close_shift_2</td>
      <td>0.000250</td>
    </tr>
    <tr>
      <th>9</th>
      <td>minute</td>
      <td>0.000236</td>
    </tr>
    <tr>
      <th>12</th>
      <td>close_shift_3</td>
      <td>0.000233</td>
    </tr>
    <tr>
      <th>13</th>
      <td>close_shift_4</td>
      <td>0.000228</td>
    </tr>
    <tr>
      <th>31</th>
      <td>close_shift_1_lower_bb</td>
      <td>0.000224</td>
    </tr>
    <tr>
      <th>1</th>
      <td>high</td>
      <td>0.000224</td>
    </tr>
    <tr>
      <th>24</th>
      <td>ema_10</td>
      <td>0.000221</td>
    </tr>
    <tr>
      <th>22</th>
      <td>bb_low</td>
      <td>0.000221</td>
    </tr>
    <tr>
      <th>23</th>
      <td>ema_5</td>
      <td>0.000217</td>
    </tr>
    <tr>
      <th>2</th>
      <td>low</td>
      <td>0.000216</td>
    </tr>
    <tr>
      <th>15</th>
      <td>sma_5</td>
      <td>0.000215</td>
    </tr>
    <tr>
      <th>21</th>
      <td>bb_up</td>
      <td>0.000214</td>
    </tr>
    <tr>
      <th>14</th>
      <td>close_shift_5</td>
      <td>0.000214</td>
    </tr>
    <tr>
      <th>30</th>
      <td>close_shift_1_upper_bb</td>
      <td>0.000207</td>
    </tr>
    <tr>
      <th>0</th>
      <td>open</td>
      <td>0.000206</td>
    </tr>
    <tr>
      <th>16</th>
      <td>sma_10</td>
      <td>0.000201</td>
    </tr>
    <tr>
      <th>25</th>
      <td>ema_shift_5</td>
      <td>0.000200</td>
    </tr>
    <tr>
      <th>20</th>
      <td>sma_20</td>
      <td>0.000198</td>
    </tr>
    <tr>
      <th>17</th>
      <td>sma_shift_5</td>
      <td>0.000196</td>
    </tr>
    <tr>
      <th>29</th>
      <td>close_shift_1_ma20</td>
      <td>0.000195</td>
    </tr>
    <tr>
      <th>19</th>
      <td>sma_shiftmedian_10</td>
      <td>0.000185</td>
    </tr>
    <tr>
      <th>18</th>
      <td>sma_shiftmedian_5</td>
      <td>0.000184</td>
    </tr>
  </tbody>
</table>
</div>
</div>

</div>

</div>
</div>

</div>
    

    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">tree_depths</span> <span class="o">=</span> <span class="p">[</span><span class="n">estimator</span><span class="o">.</span><span class="n">tree_</span><span class="o">.</span><span class="n">max_depth</span> <span class="k">for</span> <span class="n">estimator</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">estimators_</span><span class="p">]</span>
<span class="n">tree_depths</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>[36,
 36,
 38,
 36,
 40,
 34,
 39,
 36,
 40,
 40,
 37,
 40,
 39,
 32,
 39,
 40,
 35,
 35,
 38,
 34,
 38,
 40,
 39,
 35,
 33,
 37,
 37,
 40,
 34,
 34,
 38,
 36,
 32,
 34,
 36,
 38,
 34,
 36,
 39,
 35,
 38,
 40,
 34,
 39,
 40,
 34,
 32,
 36,
 38,
 37,
 40,
 35,
 40,
 34,
 36,
 29,
 40,
 40,
 35,
 35,
 38,
 34,
 33,
 40,
 35,
 35,
 33,
 38,
 36,
 40,
 40,
 36,
 36,
 39,
 40,
 37,
 38,
 36,
 40,
 40,
 40,
 32,
 40,
 40,
 36,
 39,
 36,
 38,
 35,
 37,
 34,
 38,
 40,
 34,
 40,
 37,
 40,
 38,
 35,
 37,
 38,
 38,
 32,
 37,
 40,
 34,
 36,
 37,
 38,
 33]</pre>
</div>

</div>

</div>
</div>

</div>
    

    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">input_cols</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;open&#39;</span><span class="p">,</span> <span class="s1">&#39;high&#39;</span><span class="p">,</span> <span class="s1">&#39;low&#39;</span><span class="p">,</span> <span class="s1">&#39;close&#39;</span><span class="p">,</span> <span class="s1">&#39;volume&#39;</span><span class="p">,</span> <span class="s1">&#39;quote_asset_volume&#39;</span><span class="p">,</span>
       <span class="s1">&#39;number_of_trades&#39;</span><span class="p">,</span> <span class="s1">&#39;taker_buy_base_volume&#39;</span><span class="p">,</span> <span class="s1">&#39;taker_buy_quote_volume&#39;</span><span class="p">,</span>
       <span class="s1">&#39;minute&#39;</span><span class="p">,</span> <span class="s1">&#39;close_shift_1&#39;</span><span class="p">,</span> <span class="s1">&#39;close_shift_2&#39;</span><span class="p">,</span> <span class="s1">&#39;close_shift_3&#39;</span><span class="p">,</span>
       <span class="s1">&#39;close_shift_4&#39;</span><span class="p">,</span> <span class="s1">&#39;close_shift_5&#39;</span><span class="p">,</span> <span class="s1">&#39;sma_5&#39;</span><span class="p">,</span> <span class="s1">&#39;sma_10&#39;</span><span class="p">,</span> <span class="s1">&#39;sma_shift_5&#39;</span><span class="p">,</span>
       <span class="s1">&#39;sma_shiftmedian_5&#39;</span><span class="p">,</span> <span class="s1">&#39;sma_shiftmedian_10&#39;</span><span class="p">,</span> <span class="s1">&#39;sma_20&#39;</span><span class="p">,</span> <span class="s1">&#39;bb_up&#39;</span><span class="p">,</span> <span class="s1">&#39;bb_low&#39;</span><span class="p">,</span>
       <span class="s1">&#39;ema_5&#39;</span><span class="p">,</span> <span class="s1">&#39;ema_10&#39;</span><span class="p">,</span> <span class="s1">&#39;ema_shift_5&#39;</span><span class="p">,</span> <span class="s1">&#39;ema_crossover&#39;</span><span class="p">,</span> <span class="s1">&#39;close_diff&#39;</span><span class="p">,</span>
       <span class="s1">&#39;close_shift_1_volatility&#39;</span><span class="p">,</span> <span class="s1">&#39;close_shift_1_ma20&#39;</span><span class="p">,</span>
       <span class="s1">&#39;close_shift_1_upper_bb&#39;</span><span class="p">,</span> <span class="s1">&#39;close_shift_1_lower_bb&#39;</span><span class="p">,</span> <span class="s1">&#39;close_momentum_5&#39;</span><span class="p">,</span>
       <span class="s1">&#39;close_to_shift_ratio&#39;</span><span class="p">]</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.impute</span> <span class="kn">import</span> <span class="n">SimpleImputer</span>

<span class="n">imputer</span> <span class="o">=</span> <span class="n">SimpleImputer</span><span class="p">(</span><span class="n">strategy</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">)</span>  
<span class="n">test_df</span><span class="p">[</span><span class="n">input_cols</span><span class="p">]</span> <span class="o">=</span> <span class="n">imputer</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">test_df</span><span class="p">[</span><span class="n">input_cols</span><span class="p">])</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">test_df</span><span class="p">[</span><span class="n">input_cols</span><span class="p">]</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">test_df</span><span class="p">[</span><span class="n">input_cols</span><span class="p">])</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">test_df</span> <span class="o">=</span> <span class="n">test_df</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="s1">&#39;row_id&#39;</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">test_df</span><span class="o">.</span><span class="n">columns</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>Index([&#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39;, &#39;quote_asset_volume&#39;,
       &#39;number_of_trades&#39;, &#39;taker_buy_base_volume&#39;, &#39;taker_buy_quote_volume&#39;,
       &#39;minute&#39;, &#39;close_shift_1&#39;, &#39;close_shift_2&#39;, &#39;close_shift_3&#39;,
       &#39;close_shift_4&#39;, &#39;close_shift_5&#39;, &#39;sma_5&#39;, &#39;sma_10&#39;, &#39;sma_shift_5&#39;,
       &#39;sma_shiftmedian_5&#39;, &#39;sma_shiftmedian_10&#39;, &#39;sma_20&#39;, &#39;bb_up&#39;, &#39;bb_low&#39;,
       &#39;ema_5&#39;, &#39;ema_10&#39;, &#39;ema_shift_5&#39;, &#39;ema_crossover&#39;, &#39;close_diff&#39;,
       &#39;close_shift_1_volatility&#39;, &#39;close_shift_1_ma20&#39;,
       &#39;close_shift_1_upper_bb&#39;, &#39;close_shift_1_lower_bb&#39;, &#39;close_momentum_5&#39;,
       &#39;close_to_shift_ratio&#39;],
      dtype=&#39;object&#39;)</pre>
</div>

</div>

</div>
</div>

</div>
    

    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">test_target</span><span class="o">=</span><span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">test_df</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stderr output_text">
<pre>/opt/conda/lib/python3.10/site-packages/sklearn/base.py:432: UserWarning: X has feature names, but RandomForestClassifier was fitted without feature names
  warnings.warn(
[Parallel(n_jobs=4)]: Using backend ThreadingBackend with 4 concurrent workers.
[Parallel(n_jobs=4)]: Done  33 tasks      | elapsed:    1.5s
[Parallel(n_jobs=4)]: Done 110 out of 110 | elapsed:    5.0s finished
</pre>
</div>
</div>

</div>
</div>

</div>
    

    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">submission</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
    <span class="s1">&#39;row_id&#39;</span><span class="p">:</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">909617</span><span class="p">),</span>
    <span class="s1">&#39;target&#39;</span><span class="p">:</span> <span class="n">test_target</span>
<span class="p">})</span>

<span class="n">submission</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="s1">&#39;submission.csv&#39;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

</div>]]></content><author><name></name></author><summary type="html"><![CDATA[summary]]></summary></entry><entry><title type="html">RAG with User Interaction</title><link href="https://kozodoi.me/blog/20231113/rag-with-human-interaction" rel="alternate" type="text/html" title="RAG with User Interaction" /><published>2023-11-13T00:00:00-06:00</published><updated>2023-11-13T00:00:00-06:00</updated><id>https://kozodoi.me/blog/20231113/rag-with-user</id><content type="html" xml:base="https://kozodoi.me/blog/20231113/rag-with-human-interaction"><![CDATA[<p>This post was originally published on the <a href="https://aws.amazon.com/blogs/machine-learning/improve-llm-responses-in-rag-use-cases-by-interacting-with-the-user/">AWS ML Blog</a></p>

<h1 id="1.-Introduction">1. Introduction<a class="anchor-link" href="#1.-Introduction"> </a>
<p>One of the most common applications of generative AI and large language models (LLMs) is answering questions based on a specific external knowledge corpus. Retrieval-Augmented Generation (RAG) is a popular technique for building question answering systems that use an external knowledge base. To learn more, refer to Build a powerful question answering bot with Amazon SageMaker, Amazon OpenSearch Service, Streamlit, and LangChain.</p>
<p>Traditional RAG systems often struggle to provide satisfactory answers when users ask vague or ambiguous questions without providing sufficient context. This leads to unhelpful responses like “I don’t know” or incorrect, made-up answers provided by an LLM. In this post, we demonstrate a solution to improve the quality of answers in such use cases over traditional RAG systems by introducing an interactive clarification component using LangChain.</p>
<p>The key idea is to enable the RAG system to engage in a conversational dialogue with the user when the initial question is unclear. By asking clarifying questions, prompting the user for more details, and incorporating the new contextual information, the RAG system can gather the necessary context to provide an accurate, helpful answer—even from an ambiguous initial user query.</p>

<h1 id="2.-Full Post">2. Full Post<a class="anchor-link" href="#2.-Full Post"> </a>
<p>... <a href="https://aws.amazon.com/blogs/machine-learning/improve-llm-responses-in-rag-use-cases-by-interacting-with-the-user/"> (continue reading here)</a></p>
</h1></h1>]]></content><author><name>Antonia Wiebeler, Nikita Kozodoi</name></author><category term="generative ai" /><category term="natural language processing" /><category term="web app" /><summary type="html"><![CDATA[Improve LLM responses in RAG use cases by interacting with the user]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://kozodoi.me/images/posts/rag.png" /><media:content medium="image" url="https://kozodoi.me/images/posts/rag.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Implementing PCA from Scratch</title><link href="https://kozodoi.me/blog/20230326/pca-from-scratch" rel="alternate" type="text/html" title="Implementing PCA from Scratch" /><published>2023-03-26T00:00:00-05:00</published><updated>2023-03-26T00:00:00-05:00</updated><id>https://kozodoi.me/blog/20230326/pca-from-scratch</id><content type="html" xml:base="https://kozodoi.me/blog/20230326/pca-from-scratch"><![CDATA[<!--
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: _notebooks/2023-03-26-pca-from-scratch.ipynb
-->

<div class="container" id="notebook-container">
        
    
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><em>Last update: 26.03.2023. All opinions are my own.</em></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="1.-Overview">1. Overview<a class="anchor-link" href="#1.-Overview"> </a></h1><p>This blog post provides a tutorial on implementing the Principal Component Analysis algorithm using Python and NumPy. We will set up a simple class object, implement relevant methods to perform the decomposition, and illustrate how it works on a toy dataset.</p>
<p>Why are we implementing PCA from scratch if the algorithm is already available in <code>scikit-learn</code>? First, coding something from scratch is the best way to understand it. You may know many ML algorithms, but being able to write it down indicates that you have really mastered it. Second, implementing algorithms from scratch is a common task in ML interviews in tech companies, which makes it a useful skill that a job candidate should practice. Last but not least, it's a fun exercise, right? :)</p>
<p>This post is part of <a href="https://kozodoi.me/search/#ML%20from%20scratch">"ML from Scratch"</a> series, where we implement established ML algorithms in Python. Check out other posts to see further implementations.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="2.-How-PCA-works">2. How PCA works<a class="anchor-link" href="#2.-How-PCA-works"> </a></h1><p>Before jumping to implementation, let's quickly refresh our minds. How does PCA work?</p>
<p>PCA is a popular unsupervised algorithm used for dimensionality reduction. In a nutshell, PCA helps you to reduce the number of feature in your dataset by combining the features without loosing too much information. More specifically, PCA finds a linear data transformation that projects the data into a new coordinate system with a fewer dimensions. To capture the most variation in the original data, this projection is done by finding the so-called principal components - eigenvectors of the data's covariance matrix - and multiplying the actual data matrix with a subset of the components. This procedure is what we are going to implement.</p>
<p>P.S. If you need a more detailed summary of how PCA works, check out <a href="https://en.wikipedia.org/wiki/Principal_component_analysis">this Wiki page</a>.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="3.-Implementing-PCA">3. Implementing PCA<a class="anchor-link" href="#3.-Implementing-PCA"> </a></h1><p>Let's start the implementation! The only library we need to import is <code>numpy</code>:</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>In line with object-oriented programming practices, we will implement PCA as a class with a set of methods. We will need the following five:</p>
<ol>
<li><code>__init__()</code>: initialize the class object.</li>
<li><code>fit()</code>: center the data and identify principal components.</li>
<li><code>transform()</code>: transform new data into the identified components.</li>
</ol>
<p>Let's sketch a class object template. Since we implement functions as class methods, we include <code>self</code> argument for each method:</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">class</span> <span class="nc">PCA</span><span class="p">:</span>
    
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>
    
    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find principal components</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>
    
    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform new data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now let's go through each method one by one.</p>
<p>The <code>__init__()</code> method is run once when the initialize the PCA class object.</p>
<p>One thing need to do on the initialization step is to store meta-parameters of our algorithm. For PCA, there is only one meta-parameter we will specify: the number of components. We will save it as <code>self.num_components</code>.</p>
<p>Apart from the meta-parameters, we will create three placeholders that we will use to store important class attributes:</p>
<ul>
<li><code>self.components</code>: array with the principal component weights</li>
<li><code>self.mean</code>: mean variable values observed in the training data </li>
<li><code>self.variance_share</code>: proportion of variance explained by principal components</li>
</ul>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_components</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">num_components</span> <span class="o">=</span> <span class="n">num_components</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">components</span>     <span class="o">=</span> <span class="kc">None</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">mean</span>           <span class="o">=</span> <span class="kc">None</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">variance_share</span> <span class="o">=</span> <span class="kc">None</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Next, let's implement the <code>fit()</code> method - the heart of our PCA class. This method will be applied to a provided dataset to identify and memorize principal components.</p>
<p>We will do the following steps:</p>
<ol>
<li>Center the data by subtracting the mean values for each variable. Normalizing variables is important to make sure that their impact in the data variation is similar and does not depend on the range of that variable. We will also memorize the mean values as <code>self.mean</code> as we will need it later for the data transformation.</li>
<li>Calculate eigenvectors of the covariance matrix. First, we will use <code>np.cov()</code> to get the covariance matrix of the data. Next, we will leverage <code>np.linalg.eig()</code> to do the eigenvalue decomposition and obtain both eigenvalues and eigenvectors.</li>
<li>Sort eigenvalues and eigenvectors in the decreasing order. Since we will use a smaller number of components compared to the number of variables in the original data, we would like to focus on components that reflect more data variation. In our case, eigenvectors that correspond to larger eigenvalues capture more variation.</li>
<li>Store an array with the top <code>num_components</code> components as <code>self.components</code>.</li>
</ol>
<p>Finally, we will calculate and memorize the data variation explained by the selected components as <code>self.variance_share</code>. This can be computed as a cumulative sum of the corresponding eigenvalues divided by the total sum of eigenvalues.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find principal components</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># data centering</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">X</span>        <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean</span>
    
    <span class="c1"># calculate eigenvalues &amp; vectors</span>
    <span class="n">cov_matrix</span>      <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="n">values</span><span class="p">,</span> <span class="n">vectors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">cov_matrix</span><span class="p">)</span>
    
    <span class="c1"># sort eigenvalues &amp; vectors </span>
    <span class="n">sort_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">values</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">values</span>   <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="n">sort_idx</span><span class="p">]</span>
    <span class="n">vectors</span>  <span class="o">=</span> <span class="n">vectors</span><span class="p">[:,</span> <span class="n">sort_idx</span><span class="p">]</span>
    
    <span class="c1"># store principal components &amp; variance</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">components</span> <span class="o">=</span> <span class="n">vectors</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">num_components</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">variance_share</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">values</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">num_components</span><span class="p">])</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The most difficult part is over! Last but not least, we will implement a method to perform the data transformation.</p>
<p>This will be run after calling the <code>fit()</code> method on the training data, so we only need to implement two steps:</p>
<ol>
<li>Center the new data using the same mean values that we used on the fitting stage.</li>
<li>Multiply the data matrix with the matrix of the selected components. Note that we will need to transpose the components matrix to ensure the right dimensionality.</li>
</ol>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transform data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># data centering</span>
    <span class="n">X</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean</span>
    
    <span class="c1"># decomposition</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Putting everything together, this is how our implementation looks like:</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">class</span> <span class="nc">PCA</span><span class="p">:</span>
    
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_components</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_components</span> <span class="o">=</span> <span class="n">num_components</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">components</span>     <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mean</span>           <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variance_share</span> <span class="o">=</span> <span class="kc">None</span>
    
    
    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find principal components</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># data centering</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">X</span>        <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean</span>
        
        <span class="c1"># calculate eigenvalues &amp; vectors</span>
        <span class="n">cov_matrix</span>      <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">values</span><span class="p">,</span> <span class="n">vectors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">cov_matrix</span><span class="p">)</span>
        
        <span class="c1"># sort eigenvalues &amp; vectors </span>
        <span class="n">sort_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">values</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">values</span>   <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="n">sort_idx</span><span class="p">]</span>
        <span class="n">vectors</span>  <span class="o">=</span> <span class="n">vectors</span><span class="p">[:,</span> <span class="n">sort_idx</span><span class="p">]</span>
        
        <span class="c1"># store principal components &amp; variance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">components</span> <span class="o">=</span> <span class="n">vectors</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">num_components</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variance_share</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">values</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">num_components</span><span class="p">])</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
    
    
    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># data centering</span>
        <span class="n">X</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean</span>
        
        <span class="c1"># decomposition</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="4.-Testing-the-implementation">4. Testing the implementation<a class="anchor-link" href="#4.-Testing-the-implementation"> </a></h1><p>Now that we have our implementation, let's check whether it actually works. We will generate two toy data samples with 10 features using the <code>np.random</code> module to draw feature values from a random Normal distribution:</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">X_old</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">loc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="n">X_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">loc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="mi">500</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span> 

<span class="nb">print</span><span class="p">(</span><span class="n">X_old</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">X_new</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>(1000, 10) (500, 10)
</pre>
</div>
</div>

</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now, let's instantiate our PCA class, fit it on the old data and transform both datasets!</p>
<p>To see if the algorithm works properly, we will generate four new examples as <code>X_new</code>, gradually increasing the feature values from 1 to 5. We expect the label predicted by KNN to increase from 0 to 1, since we are getting closer to examples in <code>X1</code>. Let's check!</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># initialize PCA object</span>
<span class="n">pca</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">num_components</span> <span class="o">=</span> <span class="mi">8</span><span class="p">)</span>

<span class="c1"># fit PCA on old data</span>
<span class="n">pca</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_old</span><span class="p">)</span>

<span class="c1"># check explained variance</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Explained variance: </span><span class="si">{</span><span class="n">pca</span><span class="o">.</span><span class="n">variance_share</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Explained variance: 0.8325
</pre>
</div>
</div>

</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Eight components explain more than 83% of the data variation. Not bad! Let's transform the data:</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># transform datasets</span>
<span class="n">X_old</span> <span class="o">=</span> <span class="n">pca</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_old</span><span class="p">)</span>
<span class="n">X_new</span> <span class="o">=</span> <span class="n">pca</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_new</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">X_old</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">X_new</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>(1000, 8) (500, 8)
</pre>
</div>
</div>

</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Yay! Everything works as expected. The new datasets have eight features instead of the original ten features.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="5.-Closing-words">5. Closing words<a class="anchor-link" href="#5.-Closing-words"> </a></h1><p>This is it! I hope this tutorial helps you to refresh your memory on how PCA works and gives you a good idea on how to implement it yourself. You are now well-equipped to do this exercise on your own!</p>
<p>If you liked this tutorial, feel free to share it on social media and buy me a coffee :) Don't forget to check out other posts in the <a href="https://kozodoi.me/search/#ML%20from%20scratch">"ML from Scratch"</a> series. Happy learning!</p>

</div>
</div>
</div>
</div>

<script type="application/vnd.jupyter.widget-state+json">
{"state": {"13c1b0b60dc243baa0859d1c6bd17129": {"model_module": "@jupyter-widgets/controls", "model_module_version": "1.5.0", "model_name": "FloatProgressModel", "state": {"_dom_classes": [], "_model_module": "@jupyter-widgets/controls", "_model_module_version": "1.5.0", "_model_name": "FloatProgressModel", "_view_count": null, "_view_module": "@jupyter-widgets/controls", "_view_module_version": "1.5.0", "_view_name": "ProgressView", "bar_style": "success", "description": "100%", "description_tooltip": null, "layout": "IPY_MODEL_6ec176035b11447582886c6d337eeff6", "max": 87306240, "min": 0, "orientation": "horizontal", "style": "IPY_MODEL_b89c0127f3a94527b58b7d710c43e951", "value": 87306240}}, "149e60260f0b49268d9e6ce0c8461dce": {"model_module": "@jupyter-widgets/base", "model_module_version": "1.2.0", "model_name": "LayoutModel", "state": {"_model_module": "@jupyter-widgets/base", "_model_module_version": "1.2.0", "_model_name": "LayoutModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "1.2.0", "_view_name": "LayoutView", "align_content": null, "align_items": null, "align_self": null, "border": null, "bottom": null, "display": null, "flex": null, "flex_flow": null, "grid_area": null, "grid_auto_columns": null, "grid_auto_flow": null, "grid_auto_rows": null, "grid_column": null, "grid_gap": null, "grid_row": null, "grid_template_areas": null, "grid_template_columns": null, "grid_template_rows": null, "height": null, "justify_content": null, "justify_items": null, "left": null, "margin": null, "max_height": null, "max_width": null, "min_height": null, "min_width": null, "object_fit": null, "object_position": null, "order": null, "overflow": null, "overflow_x": null, "overflow_y": null, "padding": null, "right": null, "top": null, "visibility": null, "width": null}}, "19703cdff07249fab2d78d23d35192f3": {"model_module": "@jupyter-widgets/controls", "model_module_version": "1.5.0", "model_name": "HTMLModel", "state": {"_dom_classes": [], "_model_module": "@jupyter-widgets/controls", "_model_module_version": "1.5.0", "_model_name": "HTMLModel", "_view_count": null, "_view_module": "@jupyter-widgets/controls", "_view_module_version": "1.5.0", "_view_name": "HTMLView", "description": "", "description_tooltip": null, "layout": "IPY_MODEL_149e60260f0b49268d9e6ce0c8461dce", "placeholder": "\u200b", "style": "IPY_MODEL_68071ef4d8ad4ce782ddc9b045860848", "value": " 83.3M/83.3M [00:00&lt;00:00, 116MB/s]"}}, "44310773133f44999edfef5f5ff34fbb": {"model_module": "@jupyter-widgets/controls", "model_module_version": "1.5.0", "model_name": "HBoxModel", "state": {"_dom_classes": [], "_model_module": "@jupyter-widgets/controls", "_model_module_version": "1.5.0", "_model_name": "HBoxModel", "_view_count": null, "_view_module": "@jupyter-widgets/controls", "_view_module_version": "1.5.0", "_view_name": "HBoxView", "box_style": "", "children": ["IPY_MODEL_13c1b0b60dc243baa0859d1c6bd17129", "IPY_MODEL_19703cdff07249fab2d78d23d35192f3"], "layout": "IPY_MODEL_ef696dddbf0e4bdf851a3c08acd0a3c9"}}, "68071ef4d8ad4ce782ddc9b045860848": {"model_module": "@jupyter-widgets/controls", "model_module_version": "1.5.0", "model_name": "DescriptionStyleModel", "state": {"_model_module": "@jupyter-widgets/controls", "_model_module_version": "1.5.0", "_model_name": "DescriptionStyleModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "1.2.0", "_view_name": "StyleView", "description_width": ""}}, "6ec176035b11447582886c6d337eeff6": {"model_module": "@jupyter-widgets/base", "model_module_version": "1.2.0", "model_name": "LayoutModel", "state": {"_model_module": "@jupyter-widgets/base", "_model_module_version": "1.2.0", "_model_name": "LayoutModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "1.2.0", "_view_name": "LayoutView", "align_content": null, "align_items": null, "align_self": null, "border": null, "bottom": null, "display": null, "flex": null, "flex_flow": null, "grid_area": null, "grid_auto_columns": null, "grid_auto_flow": null, "grid_auto_rows": null, "grid_column": null, "grid_gap": null, "grid_row": null, "grid_template_areas": null, "grid_template_columns": null, "grid_template_rows": null, "height": null, "justify_content": null, "justify_items": null, "left": null, "margin": null, "max_height": null, "max_width": null, "min_height": null, "min_width": null, "object_fit": null, "object_position": null, "order": null, "overflow": null, "overflow_x": null, "overflow_y": null, "padding": null, "right": null, "top": null, "visibility": null, "width": null}}, "b89c0127f3a94527b58b7d710c43e951": {"model_module": "@jupyter-widgets/controls", "model_module_version": "1.5.0", "model_name": "ProgressStyleModel", "state": {"_model_module": "@jupyter-widgets/controls", "_model_module_version": "1.5.0", "_model_name": "ProgressStyleModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "1.2.0", "_view_name": "StyleView", "bar_color": null, "description_width": "initial"}}, "ef696dddbf0e4bdf851a3c08acd0a3c9": {"model_module": "@jupyter-widgets/base", "model_module_version": "1.2.0", "model_name": "LayoutModel", "state": {"_model_module": "@jupyter-widgets/base", "_model_module_version": "1.2.0", "_model_name": "LayoutModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "1.2.0", "_view_name": "LayoutView", "align_content": null, "align_items": null, "align_self": null, "border": null, "bottom": null, "display": null, "flex": null, "flex_flow": null, "grid_area": null, "grid_auto_columns": null, "grid_auto_flow": null, "grid_auto_rows": null, "grid_column": null, "grid_gap": null, "grid_row": null, "grid_template_areas": null, "grid_template_columns": null, "grid_template_rows": null, "height": null, "justify_content": null, "justify_items": null, "left": null, "margin": null, "max_height": null, "max_width": null, "min_height": null, "min_width": null, "object_fit": null, "object_position": null, "order": null, "overflow": null, "overflow_x": null, "overflow_y": null, "padding": null, "right": null, "top": null, "visibility": null, "width": null}}}, "version_major": 2, "version_minor": 0}
</script>]]></content><author><name>Nikita Kozodoi</name></author><category term="python" /><category term="ML from scratch" /><category term="tutorial" /><summary type="html"><![CDATA[Principal Component Analysis in Python and NumPy]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://kozodoi.me/images/posts/pca_scratch.png" /><media:content medium="image" url="https://kozodoi.me/images/posts/pca_scratch.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Implementing KNN from Scratch</title><link href="https://kozodoi.me/blog/20230319/knn-from-scratch" rel="alternate" type="text/html" title="Implementing KNN from Scratch" /><published>2023-03-19T00:00:00-05:00</published><updated>2023-03-19T00:00:00-05:00</updated><id>https://kozodoi.me/blog/20230319/knn-from-scratch</id><content type="html" xml:base="https://kozodoi.me/blog/20230319/knn-from-scratch"><![CDATA[<!--
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: _notebooks/2023-03-19-knn-from-scratch.ipynb
-->

<div class="container" id="notebook-container">
        
    
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><em>Last update: 26.03.2023. All opinions are my own.</em></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="1.-Overview">1. Overview<a class="anchor-link" href="#1.-Overview"> </a></h1><p>This blog post provides a tutorial on implementing the K Nearest Neighbors algorithm using Python and NumPy. We will set up a simple class object, implement relevant methods to perform the prediction, and illustrate how it works on a toy dataset.</p>
<p>Why are we implementing KNN from scratch if the algorithm is already available in <code>scikit-learn</code>? First, coding something from scratch is the best way to understand it. You may know many ML algorithms, but being able to write it down indicates that you have really mastered it. Second, implementing algorithms from scratch is a common task in ML interviews in tech companies, which makes it a useful skill that a job candidate should practice. Last but not least, it's a fun exercise, right? :)</p>
<p>This post is part of <a href="https://kozodoi.me/search/#ML%20from%20scratch">"ML from Scratch"</a> series, where we implement established ML algorithms in Python. Check out other posts to see further implementations.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="2.-How-KNN-works">2. How KNN works<a class="anchor-link" href="#2.-How-KNN-works"> </a></h1><p>Before we jump to the implementation, let's quickly refresh our minds. How does KNN work?</p>
<p>KNN is one of the so-called lazy algorithms, which means that there is no actual training step. Instead, KNN memorizes the training data by storing the feature values of training examples. Given a new example to be predicted, KNN calculates distances between the new example and each of the examples in the training set. The prediction returned by the KNN algorithm is simply the average value of the target variable across the K nearest neighbors of the new example.</p>
<p>P.S. If you need a more detailed summary of how KNN works, check out <a href="https://en.wikipedia.org/wiki/K-nearest_neighbors_algorithm">this Wiki page</a>.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="3.-Implementing-KNN">3. Implementing KNN<a class="anchor-link" href="#3.-Implementing-KNN"> </a></h1><p>Let's start the implementation! The only library we need to import is <code>numpy</code>:</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">for</span> <span class="n">size</span> <span class="ow">in</span> <span class="n">layer_sizes</span><span class="p">:</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span>
        <span class="n">size</span><span class="p">,</span>
        <span class="n">kernel_initializer</span><span class="o">=</span><span class="s2">&quot;he_uniform&quot;</span><span class="p">,</span>
        <span class="n">activation</span><span class="o">=</span><span class="n">activation_fn</span><span class="p">,</span>
    <span class="p">)(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">size</span> <span class="o">&lt;</span> <span class="n">layer_sizes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">BatchNormalization</span><span class="p">()(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">Dropout</span><span class="p">(</span><span class="n">dropout_rate</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span>
    <span class="n">n_outputs</span><span class="p">,</span> <span class="n">kernel_initializer</span><span class="o">=</span><span class="s2">&quot;he_uniform&quot;</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s2">&quot;sigmoid&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;events_predictions&quot;</span>
<span class="p">)(</span><span class="n">x</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>In line with object-oriented programming practices, we will implement KNN as a class with a set of methods. We will need the following five:</p>
<ol>
<li><code>__init__()</code>: initialize the class object.</li>
<li><code>fit()</code>: memorize the training data and store it as a class variable.</li>
<li><code>predict()</code>: predict label for a new example.</li>
<li><code>get_distance()</code>: helper function to calculate distance between two examples.</li>
<li><code>get_neighbors()</code>: helper function to find and rank neighbors by distance.</li>
</ol>
<p>The last two functions are optional: we can implement the logic inside the <code>predict()</code> method, but it will be easier to split the steps.</p>
<p>Let's sketch a class object template. Since we implement functions as class methods, we include <code>self</code> argument for each method:</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">class</span> <span class="nc">KNN</span><span class="p">:</span>
    
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>
    
    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Memorize training data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>
    
    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Predict labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">get_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate distance between two examples</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>    
    
    <span class="k">def</span> <span class="nf">get_neighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find nearest neighbors</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now let's go through each method one by one.</p>
<p>The <code>__init__()</code> method is run once when the initialize the KNN class object. The only thing we need to do on the initialization step is to store meta-parameters of our algorithm. For KNN, there is only one key meta-parameter we specify: the number of neighbors. We will save it as <code>self.num_neighbors</code>:</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_neighbors</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">num_neighbors</span> <span class="o">=</span> <span class="n">num_neighbors</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Next, let's implement the <code>fit()</code> method. As we mentioned above, on the training stage, KNN needs to memorize the training data. To simplify further calculations, we will provide the input data as two <code>numpy</code> arrays: features saved as <code>self.X</code> and labels saved as <code>self.y</code>:</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Memorize training data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="n">X</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now, let's write down a helper function to calculate distance between two examples, which are two <code>numpy</code> arrays with feature values. For simplicity, we will assume that all features are numeric. One of the most commonly used distance metrics is the Euclidean distance, which is calculated as a root of the sum of the squared differences between feature values. If the last sentence sounds complicated, here is how simple it looks in Python:</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">get_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>  <span class="n">b</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate Euclidean distance between two examples</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now we are getting to the most difficult part of the KNN implementation! Below, we will write a helper function that finds nearest neighbors for a given example. For that, we will do several steps:</p>
<ol>
<li>Calculate distance between the provided example and each example in the memorized dataset <code>self.X</code>. </li>
<li>Sort examples in <code>self.X</code> by their distances to the provided example.</li>
<li>Return indices of the  nearest neighbors based on the <code>self.num_neighbors</code> meta-parameter.</li>
</ol>
<p>For step 1, we will leverage the <code>get_distance()</code> function defined above. The trick to implement step 2 is two save a tuple (example ID, distance) when going through the training data. This will allow to sort the examples by distance and return the relevant IDs at the same time:</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">get_neighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">example</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find and rank nearest neighbors of example</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># placeholder</span>
    <span class="n">distances</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># calculate distances as tuples (id, distance)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">)):</span>
        <span class="n">distances</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_distance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">example</span><span class="p">)))</span>

    <span class="c1"># sort by distance</span>
    <span class="n">distances</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    
    <span class="c1"># return IDs and distances top neighbors</span>
    <span class="k">return</span> <span class="n">distances</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">num_neighbors</span><span class="p">]</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The final step is to do the prediction! For this purpose, we implement the <code>predict()</code> method that expects a new dataset as a <code>numpy</code> array and provides an array with predictions. For each example in the new dataset, the method will go through its nearest neighbors identified using the <code>get_neighbors()</code> helper, and average labels across the neighbors. That's it!</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Predict labels</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># placeholder</span>
    <span class="n">predictions</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="c1"># go through examples</span>
    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)):</span>
        <span class="n">example</span>     <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">k_neighbors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_neighbors</span><span class="p">(</span><span class="n">example</span><span class="p">)</span>
        <span class="n">k_y_values</span>  <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">k_neighbors</span><span class="p">]</span>
        <span class="n">prediction</span>  <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">k_y_values</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_neighbors</span>
        <span class="n">predictions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prediction</span><span class="p">)</span>

    <span class="c1"># return predictions</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">predictions</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Putting everything together, this is how our implementation looks like:</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">### END-TO-END KNN CLASS</span>

<span class="k">class</span> <span class="nc">KNN</span><span class="p">:</span>
    
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_neighbors</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_neighbors</span> <span class="o">=</span> <span class="n">num_neighbors</span>
        
        
    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Memorize training data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">X</span> <span class="o">=</span> <span class="n">X</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>
        
        
    <span class="k">def</span> <span class="nf">get_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>  <span class="n">b</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate Euclidean distance between two examples</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>


    <span class="k">def</span> <span class="nf">get_neighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">example</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find and rank nearest neighbors of example</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># placeholder</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># calculate distances as tuples (id, distance)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">)):</span>
            <span class="n">distances</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_distance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">example</span><span class="p">)))</span>

        <span class="c1"># sort by distance</span>
        <span class="n">distances</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        
        <span class="c1"># return IDs and distances top neighbors</span>
        <span class="k">return</span> <span class="n">distances</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">num_neighbors</span><span class="p">]</span>


    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Predict labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># placeholder</span>
        <span class="n">predictions</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="c1"># go through examples</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)):</span>
            <span class="n">example</span>     <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">k_neighbors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_neighbors</span><span class="p">(</span><span class="n">example</span><span class="p">)</span>
            <span class="n">k_y_values</span>  <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">k_neighbors</span><span class="p">]</span>
            <span class="n">prediction</span>  <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">k_y_values</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_neighbors</span>
            <span class="n">predictions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prediction</span><span class="p">)</span>

        <span class="c1"># return predictions</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">predictions</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="4.-Testing-the-implementation">4. Testing the implementation<a class="anchor-link" href="#4.-Testing-the-implementation"> </a></h1><p>Now that we have our implementation, let's check whether it actually works. We will generate toy data using <code>numpy</code>. The <code>gen_data()</code> function below uses the <code>np.random</code> module to draw feature values from a random Normal distribution and assign a 0/1 label.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">### HELPER FUNCTION</span>

<span class="k">def</span> <span class="nf">gen_data</span><span class="p">(</span>
    <span class="n">mu</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> 
    <span class="n">sigma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> 
    <span class="n">y</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">size</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate random data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">loc</span> <span class="o">=</span> <span class="n">mu</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">repeats</span> <span class="o">=</span> <span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    
    <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>To simulate a simple ML problem, we will generate a dataset consisting of two samples:</p>
<ol>
<li>30 examples with mean features value of 1 and a label of 0.</li>
<li>20 examples with mean features value of 5 and a label of 1.</li>
</ol>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">### TOY DATA GENERATION</span>

<span class="n">X0</span><span class="p">,</span> <span class="n">y0</span> <span class="o">=</span> <span class="n">gen_data</span><span class="p">(</span><span class="n">mu</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="n">X1</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="n">gen_data</span><span class="p">(</span><span class="n">mu</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">X0</span><span class="p">,</span> <span class="n">X1</span><span class="p">),</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">y0</span><span class="p">,</span> <span class="n">y1</span><span class="p">),</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now, let's instantiate our KNN class, fit it on the training data and provide predictions for some new examples!</p>
<p>To see if the algorithm works properly, we will generate four new examples as <code>X_new</code>, gradually increasing the feature values from 1 to 5. We expect the label predicted by KNN to increase from 0 to 1, since we are getting closer to examples in <code>X1</code>. Let's check!</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">### PREDICTION</span>

<span class="c1"># fit KNN</span>
<span class="n">clf</span> <span class="o">=</span> <span class="n">KNN</span><span class="p">(</span><span class="n">num_neighbors</span> <span class="o">=</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">clf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

<span class="c1"># generate new examples</span>
<span class="n">X_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span>
    <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
    <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
    <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
    <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
<span class="p">))</span>

<span class="c1"># predict new examples</span>
<span class="n">clf</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_new</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>array([0. , 0.2, 0.8, 1. ])</pre>
</div>

</div>

</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Yay! Everything works as expected. Our KNN algorithm provides four predictions for the new examples, and the prediction goes up with the increase in feature values. Our job is done!</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="5.-Closing-words">5. Closing words<a class="anchor-link" href="#5.-Closing-words"> </a></h1><p>This is it! I hope this tutorial helps you to refresh your memory on how KNN works and gives you a good idea on how to implement it yourself. You are now well-equipped to do this exercise on your own!</p>
<p>If you liked this tutorial, feel free to share it on social media and buy me a coffee :) Don't forget to check out other posts in the <a href="https://kozodoi.me/search/#ML%20from%20scratch">"ML from Scratch"</a> series. Happy learning!</p>

</div>
</div>
</div>
</div>

<script type="application/vnd.jupyter.widget-state+json">
{"state": {"13c1b0b60dc243baa0859d1c6bd17129": {"model_module": "@jupyter-widgets/controls", "model_module_version": "1.5.0", "model_name": "FloatProgressModel", "state": {"_dom_classes": [], "_model_module": "@jupyter-widgets/controls", "_model_module_version": "1.5.0", "_model_name": "FloatProgressModel", "_view_count": null, "_view_module": "@jupyter-widgets/controls", "_view_module_version": "1.5.0", "_view_name": "ProgressView", "bar_style": "success", "description": "100%", "description_tooltip": null, "layout": "IPY_MODEL_6ec176035b11447582886c6d337eeff6", "max": 87306240, "min": 0, "orientation": "horizontal", "style": "IPY_MODEL_b89c0127f3a94527b58b7d710c43e951", "value": 87306240}}, "149e60260f0b49268d9e6ce0c8461dce": {"model_module": "@jupyter-widgets/base", "model_module_version": "1.2.0", "model_name": "LayoutModel", "state": {"_model_module": "@jupyter-widgets/base", "_model_module_version": "1.2.0", "_model_name": "LayoutModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "1.2.0", "_view_name": "LayoutView", "align_content": null, "align_items": null, "align_self": null, "border": null, "bottom": null, "display": null, "flex": null, "flex_flow": null, "grid_area": null, "grid_auto_columns": null, "grid_auto_flow": null, "grid_auto_rows": null, "grid_column": null, "grid_gap": null, "grid_row": null, "grid_template_areas": null, "grid_template_columns": null, "grid_template_rows": null, "height": null, "justify_content": null, "justify_items": null, "left": null, "margin": null, "max_height": null, "max_width": null, "min_height": null, "min_width": null, "object_fit": null, "object_position": null, "order": null, "overflow": null, "overflow_x": null, "overflow_y": null, "padding": null, "right": null, "top": null, "visibility": null, "width": null}}, "19703cdff07249fab2d78d23d35192f3": {"model_module": "@jupyter-widgets/controls", "model_module_version": "1.5.0", "model_name": "HTMLModel", "state": {"_dom_classes": [], "_model_module": "@jupyter-widgets/controls", "_model_module_version": "1.5.0", "_model_name": "HTMLModel", "_view_count": null, "_view_module": "@jupyter-widgets/controls", "_view_module_version": "1.5.0", "_view_name": "HTMLView", "description": "", "description_tooltip": null, "layout": "IPY_MODEL_149e60260f0b49268d9e6ce0c8461dce", "placeholder": "\u200b", "style": "IPY_MODEL_68071ef4d8ad4ce782ddc9b045860848", "value": " 83.3M/83.3M [00:00&lt;00:00, 116MB/s]"}}, "44310773133f44999edfef5f5ff34fbb": {"model_module": "@jupyter-widgets/controls", "model_module_version": "1.5.0", "model_name": "HBoxModel", "state": {"_dom_classes": [], "_model_module": "@jupyter-widgets/controls", "_model_module_version": "1.5.0", "_model_name": "HBoxModel", "_view_count": null, "_view_module": "@jupyter-widgets/controls", "_view_module_version": "1.5.0", "_view_name": "HBoxView", "box_style": "", "children": ["IPY_MODEL_13c1b0b60dc243baa0859d1c6bd17129", "IPY_MODEL_19703cdff07249fab2d78d23d35192f3"], "layout": "IPY_MODEL_ef696dddbf0e4bdf851a3c08acd0a3c9"}}, "68071ef4d8ad4ce782ddc9b045860848": {"model_module": "@jupyter-widgets/controls", "model_module_version": "1.5.0", "model_name": "DescriptionStyleModel", "state": {"_model_module": "@jupyter-widgets/controls", "_model_module_version": "1.5.0", "_model_name": "DescriptionStyleModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "1.2.0", "_view_name": "StyleView", "description_width": ""}}, "6ec176035b11447582886c6d337eeff6": {"model_module": "@jupyter-widgets/base", "model_module_version": "1.2.0", "model_name": "LayoutModel", "state": {"_model_module": "@jupyter-widgets/base", "_model_module_version": "1.2.0", "_model_name": "LayoutModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "1.2.0", "_view_name": "LayoutView", "align_content": null, "align_items": null, "align_self": null, "border": null, "bottom": null, "display": null, "flex": null, "flex_flow": null, "grid_area": null, "grid_auto_columns": null, "grid_auto_flow": null, "grid_auto_rows": null, "grid_column": null, "grid_gap": null, "grid_row": null, "grid_template_areas": null, "grid_template_columns": null, "grid_template_rows": null, "height": null, "justify_content": null, "justify_items": null, "left": null, "margin": null, "max_height": null, "max_width": null, "min_height": null, "min_width": null, "object_fit": null, "object_position": null, "order": null, "overflow": null, "overflow_x": null, "overflow_y": null, "padding": null, "right": null, "top": null, "visibility": null, "width": null}}, "b89c0127f3a94527b58b7d710c43e951": {"model_module": "@jupyter-widgets/controls", "model_module_version": "1.5.0", "model_name": "ProgressStyleModel", "state": {"_model_module": "@jupyter-widgets/controls", "_model_module_version": "1.5.0", "_model_name": "ProgressStyleModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "1.2.0", "_view_name": "StyleView", "bar_color": null, "description_width": "initial"}}, "ef696dddbf0e4bdf851a3c08acd0a3c9": {"model_module": "@jupyter-widgets/base", "model_module_version": "1.2.0", "model_name": "LayoutModel", "state": {"_model_module": "@jupyter-widgets/base", "_model_module_version": "1.2.0", "_model_name": "LayoutModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "1.2.0", "_view_name": "LayoutView", "align_content": null, "align_items": null, "align_self": null, "border": null, "bottom": null, "display": null, "flex": null, "flex_flow": null, "grid_area": null, "grid_auto_columns": null, "grid_auto_flow": null, "grid_auto_rows": null, "grid_column": null, "grid_gap": null, "grid_row": null, "grid_template_areas": null, "grid_template_columns": null, "grid_template_rows": null, "height": null, "justify_content": null, "justify_items": null, "left": null, "margin": null, "max_height": null, "max_width": null, "min_height": null, "min_width": null, "object_fit": null, "object_position": null, "order": null, "overflow": null, "overflow_x": null, "overflow_y": null, "padding": null, "right": null, "top": null, "visibility": null, "width": null}}}, "version_major": 2, "version_minor": 0}
</script>]]></content><author><name>Nikita Kozodoi</name></author><category term="python" /><category term="ML from scratch" /><category term="tutorial" /><summary type="html"><![CDATA[K Nearest Neighbors in Python and NumPy]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://kozodoi.me/images/posts/knn_scratch.png" /><media:content medium="image" url="https://kozodoi.me/images/posts/knn_scratch.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Layer-Wise Learning Rate in PyTorch</title><link href="https://kozodoi.me/blog/20220329/discriminative-lr" rel="alternate" type="text/html" title="Layer-Wise Learning Rate in PyTorch" /><published>2022-03-29T00:00:00-05:00</published><updated>2022-03-29T00:00:00-05:00</updated><id>https://kozodoi.me/blog/20220329/discriminative-lr</id><content type="html" xml:base="https://kozodoi.me/blog/20220329/discriminative-lr"><![CDATA[<!--
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: _notebooks/2022-03-29-discriminative-lr.ipynb
-->

<div class="container" id="notebook-container">
        
    
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><em>Last update: 29.03.2022. All opinions are my own.</em></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="1.-Overview">1. Overview<a class="anchor-link" href="#1.-Overview"> </a></h1><p>In deep learning tasks, we often use transfer learning to take advantage of the available pre-trained models. Fine-tuning such models is a careful process. On the one hand, we want to adjust the model to the new data set. On the other hand, we also want to retain and leverage as much knowledge learned during pre-training as possible.</p>
<p>Discriminative learning rate is one of the tricks that can help us guide fine-tuning. By using lower learning rates on deeper layers of the network, we make sure we are not tempering too much with the model blocks that have already learned general patterns and concentrate fine-tuning on further layers.</p>
<p>This blog post provides a tutorial on implementing discriminative layer-wise learning rates in <code>PyTorch</code>. We will see how to specify individual learning rates for each of the model parameter blocks and set up the training process.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="2.-Implementation">2. Implementation<a class="anchor-link" href="#2.-Implementation"> </a></h1><p>The implementation of layer-wise learning rates is rather straightforward. It consists of three simple steps:</p>
<ol>
<li>Identifying a list of trainable layers in the neural net.</li>
<li>Setting up a list of model parameter blocks together with the corresponding learning rates.</li>
<li>Supplying the list with this information to the model optimizer.</li>
</ol>
<p>Let's go through each of these steps one by one and see how it works!</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="2.1.-Identifying-network-layers">2.1. Identifying network layers<a class="anchor-link" href="#2.1.-Identifying-network-layers"> </a></h2><p>The first step in our journey is to instantiate a model and retrieve the list of its layers. This step is essential to figure out how exactly to adjust the learning rate as we go through different parts of the network.</p>
<p>As an example, we will load one of the CNNs from the <code>timm</code> library and print out its parameter groups by iterating through <code>model.named_parameters()</code> and saving their names in a list called <code>layer_names</code>. Note that the framework discussed in this post is model-agnostic. It will work with any architecture, including CNNs, RNNs and transformers.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># instantiate model</span>
<span class="kn">import</span> <span class="nn">timm</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">timm</span><span class="o">.</span><span class="n">create_model</span><span class="p">(</span><span class="s1">&#39;resnet18&#39;</span><span class="p">,</span> <span class="n">num_classes</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>

<span class="c1"># save layer names</span>
<span class="n">layer_names</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">named_parameters</span><span class="p">()):</span>
    <span class="n">layer_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>0: conv1.weight
1: bn1.weight
2: bn1.bias
3: layer1.0.conv1.weight
4: layer1.0.bn1.weight
5: layer1.0.bn1.bias
...
58: layer4.1.bn2.weight
59: layer4.1.bn2.bias
60: fc.weight
61: fc.bias
</pre>
</div>
</div>

</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>As the output suggests, our model has 62 parameter groups. When doing a forward pass, an image is fed to the first convolutional layer named <code>conv1</code>, whose parameters are stored as <code>conv1.weight</code>. Next, the output travels through the batch normalization layer <code>bn1</code>, which has weights and biases stored as <code>bn1.weight</code> and <code>bn1.bias</code>. From that point, the output goes through the network blocks grouped into four big chunks labeled as <code>layer1</code>, ..., <code>layer4</code>. Finally, extracted features are fed into the fully connected part of the network denoted as <code>fc</code>.</p>
<p>In the cell below, we reverse the list of parameter group names to have the deepest layer in the end of the list. This will be useful on the next step.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># reverse layers</span>
<span class="n">layer_names</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
<span class="n">layer_names</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>[&#39;fc.bias&#39;,
 &#39;fc.weight&#39;,
 &#39;layer4.1.bn2.bias&#39;,
 &#39;layer4.1.bn2.weight&#39;,
 &#39;layer4.1.conv2.weight&#39;]</pre>
</div>

</div>

</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="2.2.-Specifying-learning-rates">2.2. Specifying learning rates<a class="anchor-link" href="#2.2.-Specifying-learning-rates"> </a></h2><p>Knowing the architecture of our network, we can reason about the appropriate learning rates.</p>
<p>There is some flexibility in how to approach this step. 
The key idea is to gradually reduce the learning rate when going deeper into the network. 
The first layers should already have a pretty good understanding of general domain-agnostic patterns after pre-training. 
In a computer vision setting, the first layers may have learned to distinguish simple shapes and edges; in natural language processing, the first layers may be responsible for general word relationships. 
We don't want to update parameters on the first layers too much, so it makes sense to reduce the corresponding learning rates. 
In contrast, we would like to set a higher learning rate for the final layers, especially for the fully-connected classifier part of the network. 
Those layers usually focus on domain-specific information and need to be trained on new data.</p>
<p>The easiest approach to incorporate this logic is to incrementally reduce the learning rate when going deeper into the network. 
Let's simply multiply it by a certain coefficient between 0 and 1 after each parameter group.
In our example, this would gives us 62 gradually diminishing learning rate values for 62 model blocks.</p>
<p>Let's implement it in code! Below, we set up a list of dictionaries called <code>parameters</code> that stores model parameters and learning rates. 
We will simply go through all parameter blocks and iteratively reduce and assign the appropriate learning rate.
In our example, we start with <code>lr = 0.01</code> and multiply it by <code>0.9</code> at each step.
Each item in <code>parameters</code> becomes a dictionary with two elements:</p>
<ul>
<li><code>params</code>: tensor with the model parameters</li>
<li><code>lr</code>: corresponding learning rate</li>
</ul>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># learning rate</span>
<span class="n">lr</span>      <span class="o">=</span> <span class="mf">1e-2</span>
<span class="n">lr_mult</span> <span class="o">=</span> <span class="mf">0.9</span>

<span class="c1"># placeholder</span>
<span class="n">parameters</span> <span class="o">=</span> <span class="p">[]</span>

<span class="c1"># store params &amp; learning rates</span>
<span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">layer_names</span><span class="p">):</span>
    
    <span class="c1"># display info</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s1">: lr = </span><span class="si">{</span><span class="n">lr</span><span class="si">:</span><span class="s1">.6f</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    
    <span class="c1"># append layer parameters</span>
    <span class="n">parameters</span> <span class="o">+=</span> <span class="p">[{</span><span class="s1">&#39;params&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">named_parameters</span><span class="p">()</span> <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="n">name</span> <span class="ow">and</span> <span class="n">p</span><span class="o">.</span><span class="n">requires_grad</span><span class="p">],</span>
                    <span class="s1">&#39;lr&#39;</span><span class="p">:</span>     <span class="n">lr</span><span class="p">}]</span>
    
    <span class="c1"># update learning rate</span>
    <span class="n">lr</span> <span class="o">*=</span> <span class="n">lr_mult</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>0: lr = 0.010000, fc.bias
1: lr = 0.009000, fc.weight
2: lr = 0.008100, layer4.1.bn2.bias
3: lr = 0.007290, layer4.1.bn2.weight
4: lr = 0.006561, layer4.1.conv2.weight
5: lr = 0.005905, layer4.1.bn1.bias
...
58: lr = 0.000022, layer1.0.conv1.weight
59: lr = 0.000020, bn1.bias
60: lr = 0.000018, bn1.weight
61: lr = 0.000016, conv1.weight
</pre>
</div>
</div>

</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>As you can see, we gradually reduce our learning rate from <code>0.01</code> for the bias on the classification layer to <code>0.00001</code> on the first convolutional layer. Looks good, right?!</p>
<p>Well, if you look closely, you will notice that we are setting different learning rates for parameter groups from the same layer. For example, having different learning rates for <code>fc.bias</code> and <code>fc.weight</code> does not really make that much sense. To address that, we can increment the learning rate only when going from one group of layers to another. The cell below provides an improved implementation.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description">
      <summary class="btn btn-sm" data-open="Hide Code" data-close="Show Code"></summary>
        <p><div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#collapse-hide</span>

<span class="c1"># learning rate</span>
<span class="n">lr</span>      <span class="o">=</span> <span class="mf">1e-2</span>
<span class="n">lr_mult</span> <span class="o">=</span> <span class="mf">0.9</span>

<span class="c1"># placeholder</span>
<span class="n">parameters</span>      <span class="o">=</span> <span class="p">[]</span>
<span class="n">prev_group_name</span> <span class="o">=</span> <span class="n">layer_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

<span class="c1"># store params &amp; learning rates</span>
<span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">layer_names</span><span class="p">):</span>
    
    <span class="c1"># parameter group name</span>
    <span class="n">cur_group_name</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="c1"># update learning rate</span>
    <span class="k">if</span> <span class="n">cur_group_name</span> <span class="o">!=</span> <span class="n">prev_group_name</span><span class="p">:</span>
        <span class="n">lr</span> <span class="o">*=</span> <span class="n">lr_mult</span>
    <span class="n">prev_group_name</span> <span class="o">=</span> <span class="n">cur_group_name</span>
    
    <span class="c1"># display info</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s1">: lr = </span><span class="si">{</span><span class="n">lr</span><span class="si">:</span><span class="s1">.6f</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    
    <span class="c1"># append layer parameters</span>
    <span class="n">parameters</span> <span class="o">+=</span> <span class="p">[{</span><span class="s1">&#39;params&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">named_parameters</span><span class="p">()</span> <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="n">name</span> <span class="ow">and</span> <span class="n">p</span><span class="o">.</span><span class="n">requires_grad</span><span class="p">],</span>
                    <span class="s1">&#39;lr&#39;</span><span class="p">:</span>     <span class="n">lr</span><span class="p">}]</span>
</pre></div>

    </div>
</div>
</div>
</p>
    </details>
<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>0: lr = 0.010000, fc.bias
1: lr = 0.010000, fc.weight
2: lr = 0.009000, layer4.1.bn2.bias
3: lr = 0.009000, layer4.1.bn2.weight
4: lr = 0.009000, layer4.1.conv2.weight
5: lr = 0.009000, layer4.1.bn1.bias
...
58: lr = 0.006561, layer1.0.conv1.weight
59: lr = 0.005905, bn1.bias
60: lr = 0.005905, bn1.weight
61: lr = 0.005314, conv1.weight
</pre>
</div>
</div>

</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>This looks more interesting!</p>
<p>Note that we can become very creative in customizing the learning rates and the decay speed. There is no fixed rule that always works well. In my experience, simple linear decay with a multiplier between 0.9 and 1 is a good starting point. Still, the framework provides a lot of space for experimentation, so feel free to test out your ideas and see what works best on your data!</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="2.3.-Setting-up-the-optimizer">2.3. Setting up the optimizer<a class="anchor-link" href="#2.3.-Setting-up-the-optimizer"> </a></h2><p>We are almost done. The last and the easiest step is to supply our list of model parameters together with the selected learning rates to the optimizer. In the cell below, we provide <code>parameters</code> to the Adam optimizer, which is one of the most frequently used ones in the field.</p>
<p>Note that we don't need to supply the learning rate to <code>Adam()</code> as we have already done it in our <code>parameters</code> object. As long as individual learning rates are available, <code>optimizer</code> will prioritize them over the single learning rate supplied to the <code>Adam()</code> call.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># set up optimizer</span>
<span class="kn">import</span> <span class="nn">torch.optim</span> <span class="k">as</span> <span class="nn">optim</span>
<span class="n">optimizer</span> <span class="o">=</span> <span class="n">optim</span><span class="o">.</span><span class="n">Adam</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>This is it! Now we can proceed to training our model as usual. When calling <code>optimizer.step()</code> inside the training loop, the optimizer will update model parameters by  subtracting the gradient multiplied by the corresponding group-wise learning rates. This implies that there is no need to adjust the training loop, which usually looks something like this:</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description">
      <summary class="btn btn-sm" data-open="Hide Code" data-close="Show Code"></summary>
        <p><div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#collapse-hide</span>

<span class="c1"># loop through batches</span>
<span class="k">for</span> <span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span> <span class="ow">in</span> <span class="n">data_loader</span><span class="p">:</span>

    <span class="c1"># extract inputs and labels</span>
    <span class="n">inputs</span> <span class="o">=</span> <span class="n">inputs</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>

    <span class="c1"># passes and weights update</span>
    <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">set_grad_enabled</span><span class="p">(</span><span class="kc">True</span><span class="p">):</span>
        
        <span class="c1"># forward pass </span>
        <span class="n">preds</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
        <span class="n">loss</span>  <span class="o">=</span> <span class="n">criterion</span><span class="p">(</span><span class="n">preds</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>

        <span class="c1"># backward pass</span>
        <span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span> 

        <span class="c1"># weights update</span>
        <span class="n">optimizer</span><span class="o">.</span><span class="n">step</span><span class="p">()</span>
        <span class="n">optimizer</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>
</p>
    </details>
</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="3.-Closing-words">3. Closing words<a class="anchor-link" href="#3.-Closing-words"> </a></h1><p>In this post, we went through the steps of implementing a layer-wise discriminative learning rate in <code>PyTorch</code>. I hope this brief tutorial will help you set up your transfer learning pipeline and squeeze out the maximum of your pre-trained model. If you are interested, check out my other blog posts on tips on deep learning and <code>PyTorch</code>. Happy learning!</p>

</div>
</div>
</div>
</div>

<script type="application/vnd.jupyter.widget-state+json">
{"state": {"13c1b0b60dc243baa0859d1c6bd17129": {"model_module": "@jupyter-widgets/controls", "model_module_version": "1.5.0", "model_name": "FloatProgressModel", "state": {"_dom_classes": [], "_model_module": "@jupyter-widgets/controls", "_model_module_version": "1.5.0", "_model_name": "FloatProgressModel", "_view_count": null, "_view_module": "@jupyter-widgets/controls", "_view_module_version": "1.5.0", "_view_name": "ProgressView", "bar_style": "success", "description": "100%", "description_tooltip": null, "layout": "IPY_MODEL_6ec176035b11447582886c6d337eeff6", "max": 87306240, "min": 0, "orientation": "horizontal", "style": "IPY_MODEL_b89c0127f3a94527b58b7d710c43e951", "value": 87306240}}, "149e60260f0b49268d9e6ce0c8461dce": {"model_module": "@jupyter-widgets/base", "model_module_version": "1.2.0", "model_name": "LayoutModel", "state": {"_model_module": "@jupyter-widgets/base", "_model_module_version": "1.2.0", "_model_name": "LayoutModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "1.2.0", "_view_name": "LayoutView", "align_content": null, "align_items": null, "align_self": null, "border": null, "bottom": null, "display": null, "flex": null, "flex_flow": null, "grid_area": null, "grid_auto_columns": null, "grid_auto_flow": null, "grid_auto_rows": null, "grid_column": null, "grid_gap": null, "grid_row": null, "grid_template_areas": null, "grid_template_columns": null, "grid_template_rows": null, "height": null, "justify_content": null, "justify_items": null, "left": null, "margin": null, "max_height": null, "max_width": null, "min_height": null, "min_width": null, "object_fit": null, "object_position": null, "order": null, "overflow": null, "overflow_x": null, "overflow_y": null, "padding": null, "right": null, "top": null, "visibility": null, "width": null}}, "19703cdff07249fab2d78d23d35192f3": {"model_module": "@jupyter-widgets/controls", "model_module_version": "1.5.0", "model_name": "HTMLModel", "state": {"_dom_classes": [], "_model_module": "@jupyter-widgets/controls", "_model_module_version": "1.5.0", "_model_name": "HTMLModel", "_view_count": null, "_view_module": "@jupyter-widgets/controls", "_view_module_version": "1.5.0", "_view_name": "HTMLView", "description": "", "description_tooltip": null, "layout": "IPY_MODEL_149e60260f0b49268d9e6ce0c8461dce", "placeholder": "\u200b", "style": "IPY_MODEL_68071ef4d8ad4ce782ddc9b045860848", "value": " 83.3M/83.3M [00:00&lt;00:00, 116MB/s]"}}, "44310773133f44999edfef5f5ff34fbb": {"model_module": "@jupyter-widgets/controls", "model_module_version": "1.5.0", "model_name": "HBoxModel", "state": {"_dom_classes": [], "_model_module": "@jupyter-widgets/controls", "_model_module_version": "1.5.0", "_model_name": "HBoxModel", "_view_count": null, "_view_module": "@jupyter-widgets/controls", "_view_module_version": "1.5.0", "_view_name": "HBoxView", "box_style": "", "children": ["IPY_MODEL_13c1b0b60dc243baa0859d1c6bd17129", "IPY_MODEL_19703cdff07249fab2d78d23d35192f3"], "layout": "IPY_MODEL_ef696dddbf0e4bdf851a3c08acd0a3c9"}}, "68071ef4d8ad4ce782ddc9b045860848": {"model_module": "@jupyter-widgets/controls", "model_module_version": "1.5.0", "model_name": "DescriptionStyleModel", "state": {"_model_module": "@jupyter-widgets/controls", "_model_module_version": "1.5.0", "_model_name": "DescriptionStyleModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "1.2.0", "_view_name": "StyleView", "description_width": ""}}, "6ec176035b11447582886c6d337eeff6": {"model_module": "@jupyter-widgets/base", "model_module_version": "1.2.0", "model_name": "LayoutModel", "state": {"_model_module": "@jupyter-widgets/base", "_model_module_version": "1.2.0", "_model_name": "LayoutModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "1.2.0", "_view_name": "LayoutView", "align_content": null, "align_items": null, "align_self": null, "border": null, "bottom": null, "display": null, "flex": null, "flex_flow": null, "grid_area": null, "grid_auto_columns": null, "grid_auto_flow": null, "grid_auto_rows": null, "grid_column": null, "grid_gap": null, "grid_row": null, "grid_template_areas": null, "grid_template_columns": null, "grid_template_rows": null, "height": null, "justify_content": null, "justify_items": null, "left": null, "margin": null, "max_height": null, "max_width": null, "min_height": null, "min_width": null, "object_fit": null, "object_position": null, "order": null, "overflow": null, "overflow_x": null, "overflow_y": null, "padding": null, "right": null, "top": null, "visibility": null, "width": null}}, "b89c0127f3a94527b58b7d710c43e951": {"model_module": "@jupyter-widgets/controls", "model_module_version": "1.5.0", "model_name": "ProgressStyleModel", "state": {"_model_module": "@jupyter-widgets/controls", "_model_module_version": "1.5.0", "_model_name": "ProgressStyleModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "1.2.0", "_view_name": "StyleView", "bar_color": null, "description_width": "initial"}}, "ef696dddbf0e4bdf851a3c08acd0a3c9": {"model_module": "@jupyter-widgets/base", "model_module_version": "1.2.0", "model_name": "LayoutModel", "state": {"_model_module": "@jupyter-widgets/base", "_model_module_version": "1.2.0", "_model_name": "LayoutModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "1.2.0", "_view_name": "LayoutView", "align_content": null, "align_items": null, "align_self": null, "border": null, "bottom": null, "display": null, "flex": null, "flex_flow": null, "grid_area": null, "grid_auto_columns": null, "grid_auto_flow": null, "grid_auto_rows": null, "grid_column": null, "grid_gap": null, "grid_row": null, "grid_template_areas": null, "grid_template_columns": null, "grid_template_rows": null, "height": null, "justify_content": null, "justify_items": null, "left": null, "margin": null, "max_height": null, "max_width": null, "min_height": null, "min_width": null, "object_fit": null, "object_position": null, "order": null, "overflow": null, "overflow_x": null, "overflow_y": null, "padding": null, "right": null, "top": null, "visibility": null, "width": null}}}, "version_major": 2, "version_minor": 0}
</script>]]></content><author><name>Nikita Kozodoi</name></author><category term="python" /><category term="deep learning" /><category term="pytorch" /><category term="tutorial" /><summary type="html"><![CDATA[Implementing discriminative learning rate across model layers]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://kozodoi.me/images/posts/lr.png" /><media:content medium="image" url="https://kozodoi.me/images/posts/lr.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Test-Time Augmentation for Tabular Data</title><link href="https://kozodoi.me/blog/20210908/tta-tabular" rel="alternate" type="text/html" title="Test-Time Augmentation for Tabular Data" /><published>2021-09-08T00:00:00-05:00</published><updated>2021-09-08T00:00:00-05:00</updated><id>https://kozodoi.me/blog/20210908/tta-tabular</id><content type="html" xml:base="https://kozodoi.me/blog/20210908/tta-tabular"><![CDATA[<!--
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: _notebooks/2021-09-08-tta-tabular.ipynb
-->

<div class="container" id="notebook-container">
        
    
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><em>Last update: 08.09.2021. All opinions are my own.</em></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="1.-Overview">1. Overview<a class="anchor-link" href="#1.-Overview"> </a></h1><p>Test time augmentation (TTA) is a <a href="https://towardsdatascience.com/test-time-augmentation-tta-and-how-to-perform-it-with-keras-4ac19b67fb4d">popular technique in computer vision</a>. TTA aims at boosting the model accuracy by using data augmentation on the inference stage. The idea behind TTA is simple: for each test image, we create multiple versions that are a little different from the original (e.g., cropped or flipped). Next, we predict labels for the test images and created copies and average model predictions over multiple versions of each image. This usually helps to improve the accuracy irrespective of the underlying model.</p>
<p>In many business settings, data comes in a tabular format. Can we use TTA with tabular data to enhance the accuracy of ML models in a way similar to computer vision models? How to define suitable transformations of test cases that do not affect the label? This blog post explores the opportunities for using TTA in tabular data environments. We will implement TTA for <code>scikit-learn</code> classifiers and test its performance on multiple credit scoring data sets. The preliminary results indicate that TTA might be a tiny bit helpful in some settings.</p>
<p><em>Note:</em> the results presented in this blog post are currently being extended within a scope of a working paper. The post will be updated once the paper is available on ArXiV.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="2.-Adapting-TTA-to-tabular-data">2. Adapting TTA to tabular data<a class="anchor-link" href="#2.-Adapting-TTA-to-tabular-data"> </a></h1><p>TTA has been originally developed for deep learning applications in computer vision. In contrast to image data, tabular data poses a more challenging environment for using TTA. We will discuss two main challenges that we need to solve to apply TTA to structured data:</p>
<ul>
<li>how to define transformations?</li>
<li>how to treat categorical features?</li>
</ul>
<h2 id="2.1.-How-to-define-transformations?">2.1. How to define transformations?<a class="anchor-link" href="#2.1.-How-to-define-transformations?"> </a></h2><p>When working with image data, light transformations such as rotation, brightness adjustment, saturation and many others modify the underlying pixel values but do not affect the ground truth. That is, a rotated cat is still a cat. We can easily verify this by visually checking the transformed images and limiting the magnitude of transformations to make sure the cat is still recognizable.</p>
<p><img src="/images/copied_from_nb/images/fig_cat.jpg" alt="" /></p>
<p>This is different for tabular data, where the underlying features represent different characteristics of the observed subjects. Let's consider a credit scoring example. In finance, banks use ML models to support loan allocation decisions. Consider a binary classification problem, where we predict whether the applicant will pay back the loan. The underlying features may describe the applicant's attributes (age, gender), loan parameters (amount, duration), macroeconomic indicators (inflation, growth). How to do transformations on these features? While there is no such thing as rotating a loan applicant (at least not within the scope of machine learning), we could do a somewhat similar exercise: create copies of each loan applicant and slightly modify feature values for each copy. A good starting point would be to add some random noise to each of the features.</p>
<p>This procedure raises a question: how can we be sure that transformations do not alter the label? Would increasing the applicant's age by 10 years affect her repayment ability? Arguably, yes. What about increasing the age by 1 year? Or 1 day? These are challenging questions that we can not answer without more information. This implies that the magnitude of the added noise has to be carefully tuned. We need to take into account the variance of each specific feature as well as the overall data set variability. Adding too little noise will create synthetic cases that are too similar to the original applications, which is not very useful. On the other hand, adding too much noise risks changing the label of the corresponding application, which would harm the model accuracy. The trade-off between these two extremes is what can potentially bring us closer to discovering an accuracy boost.</p>
<h2 id="2.2.-How-to-treat-categorical-features?">2.2. How to treat categorical features?<a class="anchor-link" href="#2.2.-How-to-treat-categorical-features?"> </a></h2><p>It is rather straightforward to add noise to continuous features such as age or income. However, tabular data frequently contains special gifts: categorical features. From gender to zip code, these features present another challenge for the application of TTA. Adding noise to the zip code appears non-trivial and requires some further thinking. Ignoring categorical features and only altering the continuous ones sounds like an easy solution, but this might not work well on data sets that contain a lot of information in the form of categorical data.</p>
<p>In this blog post, we will try a rather naive approach to deal with categorical features. Every categorical feature can be encoded as a set of dummy variables. Next, considering each dummy feature separately, we can occasionally flip the value, switching the person's gender, country of origin or education level with one click. This would introduce some variance in the categorical features and provide TTA with more diverse synthetic applications. This approach is imperfect and can be improved on, but we have to start somewhere, right?</p>
<p>Now that we have some ideas about how TTA should work and what are the main challenges, let's actually try to implement it!</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="3.-Implementing-TTA">3. Implementing TTA<a class="anchor-link" href="#3.-Implementing-TTA"> </a></h1><p>This section implements a helper function <code>predict_proba_with_tta()</code> to extend the standard <code>predict_proba()</code> method in <code>scikit-learn</code> such that predictions take advantage of the TTA procedure. We focus on a binary classification task, but one could easily extend this framework to regression tasks as well.</p>
<p>The function <code>predict_proba_with_tta()</code> requires specifying the underlying <code>scikit-learn</code> model and the test set with observations to be predicted. The function operates in four simple steps:</p>
<ol>
<li>Creating <code>num_tta</code> copies of the test set.</li>
<li>Implementing random transformations of the synthetic copies. </li>
<li>Predicting labels for the real and synthetic observations.</li>
<li>Aggregating the predictions. </li>
</ol>
<p>Considering the challenges discussed in the previous section, we implement the following transformations for the continuous features:</p>
<ul>
<li>compute STD of each continuous feature denoted as <code>std</code></li>
<li>generate a random vector <code>n</code> using the standard normal distribution</li>
<li>add <code>alpha * n * std</code> to each feature , where <code>alpha</code> is a meta-parameter. </li>
</ul>
<p>And for the categorical features:</p>
<ul>
<li>convert categorical features into a set of dummies</li>
<li>flip each dummy variable with a probability <code>beta</code>, where <code>beta</code> is a meta-parameter.</li>
</ul>
<p>By varying <code>alpha</code> and <code>beta</code>, we control the transformation magnitude, adjusting the noise scale in the synthetic copies. Higher values imply stronger transformations. The suitable values can be identified through some meta-parameter tuning.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description" open="">
      <summary class="btn btn-sm" data-open="Hide Code" data-close="Show Code"></summary>
        <p><div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#collapse-show</span>

<span class="k">def</span> <span class="nf">predict_proba_with_tta</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> 
                           <span class="n">model</span><span class="p">,</span> 
                           <span class="n">dummies</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                           <span class="n">num_tta</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> 
                           <span class="n">alpha</span>   <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span> 
                           <span class="n">beta</span>    <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span> 
                           <span class="n">seed</span>    <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Predicts class probabilities using TTA.</span>
<span class="sd">    </span>
<span class="sd">    Arguments:</span>
<span class="sd">    - data (numpy array): data set with the feature values </span>
<span class="sd">    - model (sklearn model): machine learning model</span>
<span class="sd">    - dummies (list): list of column names of dummy features</span>
<span class="sd">    - num_tta (integer): number of test-time augmentations</span>
<span class="sd">    - alpha (float): noise parameter for continuous features</span>
<span class="sd">    - beta (float): noise parameter for dummy features</span>
<span class="sd">    - seed (integer): random seed</span>

<span class="sd">    Returns:</span>
<span class="sd">    - array of predicted probabilities</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="c1"># set random seed</span>
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span> <span class="o">=</span> <span class="n">seed</span><span class="p">)</span>
    
    <span class="c1"># original prediction</span>
    <span class="n">preds</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">num_tta</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
     
    <span class="c1"># select numeric features</span>
    <span class="n">num_vars</span> <span class="o">=</span> <span class="p">[</span><span class="n">var</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="s1">&#39;object&#39;</span><span class="p">]</span>
        
    <span class="c1"># find dummies</span>
    <span class="k">if</span> <span class="n">dummies</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">num_vars</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">num_vars</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">dummies</span><span class="p">))</span>
    
    <span class="c1"># synthetic predictions</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_tta</span><span class="p">):</span>
        
        <span class="c1"># copy data</span>
        <span class="n">data_new</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    
        <span class="c1"># introduce noise to numeric vars</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">num_vars</span><span class="p">:</span>
            <span class="n">data_new</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_new</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">+</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_new</span><span class="p">))</span> <span class="o">*</span> <span class="n">data_new</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">std</span><span class="p">()</span>
            
        <span class="c1"># introduce noise to dummies</span>
        <span class="k">if</span> <span class="n">dummies</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">dummies</span><span class="p">:</span>
                <span class="n">probs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">binomial</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">beta</span><span class="p">),</span> <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_new</span><span class="p">))</span>
                <span class="n">data_new</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">probs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">data_new</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">probs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">var</span><span class="p">]</span>
            
        <span class="c1"># predict probs</span>
        <span class="n">preds_new</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">data_new</span><span class="p">)</span> 
        <span class="n">preds</span>    <span class="o">+=</span> <span class="n">preds_new</span> <span class="o">/</span> <span class="p">(</span><span class="n">num_tta</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    
    <span class="c1"># return probs</span>
    <span class="k">return</span> <span class="n">preds</span>
</pre></div>

    </div>
</div>
</div>
</p>
    </details>
</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="4.-Empirical-benchmark">4. Empirical benchmark<a class="anchor-link" href="#4.-Empirical-benchmark"> </a></h1><p>Let's test our TTA function! This section performs empirical experiment on multiple data sets to check whether TTA can improve the model performance. First, we import relevant modules and load the list of prepared data sets. All data sets come from a credit scoring environment, which represents a binary classification setup. Some of the data sets are publically available, whereas the others are subject to NDA. The public data sets include <a href="http://archive.ics.uci.edu/ml/datasets/statlog+(australian+credit+approval">australian</a>), <a href="https://archive.ics.uci.edu/ml/datasets/statlog+(german+credit+data">german</a>), <a href="https://www.kdnuggets.com/2010/03/f-pakdd-2010-data-mining-competition.html">pakdd</a>, <a href="https://www.kaggle.com/c/GiveMeSomeCredit">gmsc</a>, <a href="https://www.kaggle.com/c/home-credit-default-risk/">homecredit</a> and <a href="https://www.kaggle.com/wendykan/lending-club-loan-data">lendingclub</a>. The sample sizes and the number of features vary greatly across the datasets. This allows us to test the TTA framework in different conditions.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description">
      <summary class="btn btn-sm" data-open="Hide Code" data-close="Show Code"></summary>
        <p><div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#collapse-hide</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>

<span class="kn">from</span> <span class="nn">sklearn.ensemble</span> <span class="kn">import</span> <span class="n">RandomForestClassifier</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">StratifiedKFold</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">roc_auc_score</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">time</span>
</pre></div>

    </div>
</div>
</div>
</p>
    </details>
</div>
    

    
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description" open="">
      <summary class="btn btn-sm" data-open="Hide Code" data-close="Show Code"></summary>
        <p><div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#collapse-show</span>
<span class="n">datasets</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="s1">&#39;../data&#39;</span><span class="p">)</span>
<span class="n">datasets</span>
</pre></div>

    </div>
</div>
</div>
</p>
    </details>
<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>[&#39;thomas.csv&#39;,
 &#39;german.csv&#39;,
 &#39;hmeq.csv&#39;,
 &#39;bene2.csv&#39;,
 &#39;lendingclub.csv&#39;,
 &#39;bene1.csv&#39;,
 &#39;cashbus.csv&#39;,
 &#39;uk.csv&#39;,
 &#39;australian.csv&#39;,
 &#39;pakdd.csv&#39;,
 &#39;gmsc.csv&#39;,
 &#39;paipaidai.csv&#39;]</pre>
</div>

</div>

</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Apart from the data sets, TTA needs an underlying ML model. In our experiment, on each data set, we will use a Random Forest classifier with 500 trees, which is a good trade-off between good performance and computational resources. We will not go deep into tuning the classifier and keep the parameters fixed for all data sets. We will then use stratified 5-fold cross-validation to train and test models with and without TTA.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description" open="">
      <summary class="btn btn-sm" data-open="Hide Code" data-close="Show Code"></summary>
        <p><div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#collapse-show</span>

<span class="c1"># classifier</span>
<span class="n">clf</span> <span class="o">=</span> <span class="n">RandomForestClassifier</span><span class="p">(</span><span class="n">n_estimators</span> <span class="o">=</span> <span class="mi">500</span><span class="p">,</span> <span class="n">random_state</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_jobs</span> <span class="o">=</span> <span class="mi">4</span><span class="p">)</span>

<span class="c1"># settings</span>
<span class="n">folds</span> <span class="o">=</span> <span class="n">StratifiedKFold</span><span class="p">(</span><span class="n">n_splits</span>     <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> 
                        <span class="n">shuffle</span>      <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> 
                        <span class="n">random_state</span> <span class="o">=</span> <span class="mi">23</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>
</p>
    </details>
</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The cell below implements the following experiment:</p>
<ol>
<li>We loop through the datasets and perform cross-validation, training Random Forest on each fold combination. </li>
<li>Next, we predict labels of the validation cases and calculate the AUC of the model predictions. This is our benchmark.</li>
<li>We predict labels of the validation cases with the same model but now implement TTA to adjust the predictions.  </li>
<li>By comparing the average AUC difference before and after TTA, we can judge whether TTA actually helps to boost the predictive performance.</li>
</ol>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description" open="">
      <summary class="btn btn-sm" data-open="Hide Code" data-close="Show Code"></summary>
        <p><div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#collapse-show</span>

<span class="c1"># placeholders</span>
<span class="n">auc_change</span> <span class="o">=</span> <span class="p">[]</span>

<span class="c1"># timer</span>
<span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

<span class="c1"># modeling loop</span>
<span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">datasets</span><span class="p">:</span>

    <span class="c1">##### DATA PREPARATION</span>

    <span class="c1"># import data</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;../data/&#39;</span> <span class="o">+</span> <span class="n">data</span><span class="p">)</span>

    <span class="c1"># convert target to integer</span>
    <span class="n">X</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">X</span><span class="o">.</span><span class="n">BAD</span> <span class="o">==</span> <span class="s1">&#39;BAD&#39;</span><span class="p">,</span>  <span class="s1">&#39;BAD&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">X</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">X</span><span class="o">.</span><span class="n">BAD</span> <span class="o">==</span> <span class="s1">&#39;GOOD&#39;</span><span class="p">,</span> <span class="s1">&#39;BAD&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># extract X and y</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="s1">&#39;BAD&#39;</span><span class="p">]</span>
    <span class="k">del</span> <span class="n">X</span><span class="p">[</span><span class="s1">&#39;BAD&#39;</span><span class="p">]</span>

    <span class="c1"># create dummies</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">get_dummies</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">prefix_sep</span> <span class="o">=</span> <span class="s1">&#39;_dummy_&#39;</span><span class="p">)</span>

    <span class="c1"># data information</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;-------------------------------------&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Dataset:&#39;</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;-------------------------------------&#39;</span><span class="p">)</span>

    
    <span class="c1">##### CROSS-VALIDATION</span>
    
    <span class="c1"># create objects</span>
    <span class="n">oof_preds_raw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="n">y</span><span class="o">.</span><span class="n">nunique</span><span class="p">()))</span>
    <span class="n">oof_preds_tta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="n">y</span><span class="o">.</span><span class="n">nunique</span><span class="p">()))</span>

    <span class="c1"># modeling loop</span>
    <span class="k">for</span> <span class="n">fold_</span><span class="p">,</span> <span class="p">(</span><span class="n">trn_</span><span class="p">,</span> <span class="n">val_</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">folds</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">)):</span>

        <span class="c1"># data partitioning</span>
        <span class="n">trn_x</span><span class="p">,</span> <span class="n">trn_y</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">trn_</span><span class="p">],</span> <span class="n">y</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">trn_</span><span class="p">]</span>
        <span class="n">val_x</span><span class="p">,</span> <span class="n">val_y</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">val_</span><span class="p">],</span> <span class="n">y</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">val_</span><span class="p">]</span>

        <span class="c1"># train the model</span>
        <span class="n">clf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">trn_x</span><span class="p">,</span> <span class="n">trn_y</span><span class="p">)</span>
        
        <span class="c1"># identify dummies</span>
        <span class="n">dummies</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">like</span> <span class="o">=</span> <span class="s1">&#39;_dummy_&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>

        <span class="c1"># predictions</span>
        <span class="n">oof_preds_raw</span><span class="p">[</span><span class="n">val_</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span>  <span class="n">clf</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">val_x</span><span class="p">)</span>
        <span class="n">oof_preds_tta</span><span class="p">[</span><span class="n">val_</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span>  <span class="n">predict_proba_with_tta</span><span class="p">(</span><span class="n">data</span>    <span class="o">=</span> <span class="n">val_x</span><span class="p">,</span> 
                                                         <span class="n">model</span>   <span class="o">=</span> <span class="n">clf</span><span class="p">,</span> 
                                                         <span class="n">dummies</span> <span class="o">=</span> <span class="n">dummies</span><span class="p">,</span>
                                                         <span class="n">num_tta</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> 
                                                         <span class="n">alpha</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">trn_x</span><span class="p">))</span> <span class="o">/</span> <span class="mi">3000</span><span class="p">,</span>
                                                         <span class="n">beta</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">trn_x</span><span class="p">))</span> <span class="o">/</span> <span class="mi">30000</span><span class="p">,</span>
                                                         <span class="n">seed</span>    <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># print performance</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;- AUC before TTA = </span><span class="si">%.6f</span><span class="s1"> &#39;</span> <span class="o">%</span> <span class="n">roc_auc_score</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">oof_preds_raw</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;- AUC with TTA   = </span><span class="si">%.6f</span><span class="s1"> &#39;</span> <span class="o">%</span> <span class="n">roc_auc_score</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">oof_preds_tta</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;-------------------------------------&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    
    <span class="c1"># save the AUC delta</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="n">roc_auc_score</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">oof_preds_tta</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="n">roc_auc_score</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">oof_preds_raw</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">auc_change</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span>

<span class="c1"># display results</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;-------------------------------------&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Finished in </span><span class="si">%.1f</span><span class="s1"> minutes&#39;</span> <span class="o">%</span> <span class="p">((</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">/</span> <span class="mi">60</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;-------------------------------------&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;TTA improves AUC in </span><span class="si">%.0f</span><span class="s1">/</span><span class="si">%.0f</span><span class="s1"> cases&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">auc_change</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">datasets</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Mean AUC change = </span><span class="si">%.6f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">auc_change</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;-------------------------------------&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>
</p>
    </details>
<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>-------------------------------------
Dataset: thomas.csv (1225, 28)
-------------------------------------
- AUC before TTA = 0.612322 
- AUC with TTA   = 0.613617 
-------------------------------------

-------------------------------------
Dataset: german.csv (1000, 61)
-------------------------------------
- AUC before TTA = 0.796233 
- AUC with TTA   = 0.796300 
-------------------------------------

-------------------------------------
Dataset: hmeq.csv (5960, 20)
-------------------------------------
- AUC before TTA = 0.975995 
- AUC with TTA   = 0.976805 
-------------------------------------

-------------------------------------
Dataset: bene2.csv (7190, 28)
-------------------------------------
- AUC before TTA = 0.801193 
- AUC with TTA   = 0.799387 
-------------------------------------

-------------------------------------
Dataset: lendingclub.csv (43344, 114)
-------------------------------------
- AUC before TTA = 0.625029 
- AUC with TTA   = 0.628207 
-------------------------------------

-------------------------------------
Dataset: bene1.csv (3123, 84)
-------------------------------------
- AUC before TTA = 0.788607 
- AUC with TTA   = 0.789447 
-------------------------------------

-------------------------------------
Dataset: cashbus.csv (15000, 642)
-------------------------------------
- AUC before TTA = 0.629648 
- AUC with TTA   = 0.624874 
-------------------------------------

-------------------------------------
Dataset: uk.csv (30000, 51)
-------------------------------------
- AUC before TTA = 0.712042 
- AUC with TTA   = 0.723359 
-------------------------------------

-------------------------------------
Dataset: australian.csv (690, 42)
-------------------------------------
- AUC before TTA = 0.931787 
- AUC with TTA   = 0.931958 
-------------------------------------

-------------------------------------
Dataset: pakdd.csv (50000, 373)
-------------------------------------
- AUC before TTA = 0.620081 
- AUC with TTA   = 0.623080 
-------------------------------------

-------------------------------------
Dataset: gmsc.csv (150000, 68)
-------------------------------------
- AUC before TTA = 0.846187 
- AUC with TTA   = 0.855176 
-------------------------------------

-------------------------------------
Dataset: paipaidai.csv (60000, 1934)
-------------------------------------
- AUC before TTA = 0.716398 
- AUC with TTA   = 0.721679 
-------------------------------------

-------------------------------------
Finished in 206.1 minutes
-------------------------------------
TTA improves AUC in 10/12 cases
Mean AUC change = 0.002364
-------------------------------------
</pre>
</div>
</div>

</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Looks like TTA is working! Overall, TTA improves the AUC in 10 out of 12 data sets. The observed performance gains are rather small: on average, TTA improves AUC by <code>0.00236</code>. The results are visualized in the barplot below:</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description">
      <summary class="btn btn-sm" data-open="Hide Code" data-close="Show Code"></summary>
        <p><div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#collapse-hide</span>

<span class="n">objects</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">datasets</span><span class="p">)))</span>
<span class="n">y_pos</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">objects</span><span class="p">))</span>
<span class="n">perf</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">auc_change2</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">barh</span><span class="p">(</span><span class="n">y_pos</span><span class="p">,</span> <span class="n">perf</span><span class="p">,</span> <span class="n">align</span> <span class="o">=</span> <span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.66</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Dataset&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">yticks</span><span class="p">(</span><span class="n">y_pos</span><span class="p">,</span> <span class="n">objects</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;AUC Gain&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">12</span><span class="p">],</span> <span class="s1">&#39;k--&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>
</p>
    </details>
</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><img src="/images/copied_from_nb/images/fig_tta_gains.jpg" alt="" /></p>
<p>We should bear in mind that performance gains, although appearing rather small, come almost "for free". We don't need to train a new model and only require a relatively small amount of extra resources to create synthetic copies of the loan applications. Sounds good!</p>
<p>It is possible that further fine-tuning of the TTA meta-parameters can uncover larger performance gains. Furthermore, a considerable variance of the average gains from TTA across the data sets indicates that TTA can be more helpful in specific settings. The important factors influencing the TTA performance may relate to both the data and the classifier used to produce predictions. More research is needed to identify and analyze such factors.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="5.-Closing-words">5. Closing words<a class="anchor-link" href="#5.-Closing-words"> </a></h1><p>The purpose of this tutorial was to explore TTA applications for tabular data. We have discussed the corresponding challenges, developed a TTA wrapper function for <code>scikit-learn</code> and demonstrated that it could indeed be helpful on multiple credit scoring data sets. I hope you found this post interesting.</p>
<p>The project described in this blog post is a work in progress. I will update the post once the working paper on the usage of TTA for tabular data is available. Stay tuned and happy learning!</p>

</div>
</div>
</div>
</div>]]></content><author><name>Nikita Kozodoi</name></author><category term="python" /><category term="structured data" /><category term="test-time augmentation" /><summary type="html"><![CDATA[Improving predictive performance during inference]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://kozodoi.me/images/posts/tta.png" /><media:content medium="image" url="https://kozodoi.me/images/posts/tta.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Extracting Intermediate Layer Outputs in PyTorch</title><link href="https://kozodoi.me/blog/20210527/extracting-features" rel="alternate" type="text/html" title="Extracting Intermediate Layer Outputs in PyTorch" /><published>2021-05-27T00:00:00-05:00</published><updated>2021-05-27T00:00:00-05:00</updated><id>https://kozodoi.me/blog/20210527/extracting-features</id><content type="html" xml:base="https://kozodoi.me/blog/20210527/extracting-features"><![CDATA[<!--
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: _notebooks/2021-05-27-extracting-features.ipynb
-->

<div class="container" id="notebook-container">
        
    
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><em>Last update: 23.10.2021. All opinions are my own.</em></p>
<h1 id="1.-Overview">1. Overview<a class="anchor-link" href="#1.-Overview"> </a></h1><p>In deep learning tasks, we usually work with predictions outputted by the final layer of a neural network. In some cases, we might also be interested in the outputs of intermediate layers. Whether we want to extract data embeddings or inspect what is learned by earlier layers, it may not be straightforward how to extract the intermediate features from the network.</p>
<p>This blog post provides a quick tutorial on the extraction of intermediate activations from any layer of a deep learning model in <code>PyTorch</code> using the forward hook functionality. The important advantage of this method is its simplicity and ability to extract features without having to run the inference twice, only requiring a single forward pass through the model to save multiple outputs.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="2.-Why-do-we-need-intermediate-features?">2. Why do we need intermediate features?<a class="anchor-link" href="#2.-Why-do-we-need-intermediate-features?"> </a></h1><p>Extracting intermediate activations (also called features) can be useful in many applications. In computer vision problems, outputs of intermediate CNN layers are frequently used to visualize the learning process and illustrate visual features distinguished by the model on different layers. Another popular use case is extracting intermediate outputs to create image or text embeddings, which can be used to detect duplicate items, included as input features in a classical ML model, visualize data clusters and much more. When working with Encoder-Decoder architectures, outputs of intermediate layers can also be used to compress the data into a smaller-sized vector containing the data represenatation. There are many further use cases in which intermediate activations can be useful. So, let's discuss how to get them!</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="3.-How-to-extract-activations?">3. How to extract activations?<a class="anchor-link" href="#3.-How-to-extract-activations?"> </a></h1><p>To extract activations from intermediate layers, we will need to register a so-called forward hook for the layers of interest in our neural network and perform inference to store the relevant outputs.</p>
<p>For the purpose of this tutorial, I will use image data from a <a href="https://www.kaggle.com/c/cassava-leaf-disease-classification">Cassava Leaf Disease Classification</a> Kaggle competition. In the next few cells, we will import relevant libraries and set up a Dataloader object. Feel free to skip them if you are familiar with standard <code>PyTorch</code> data loading practices and go directly to the feature extraction part.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Preparations">Preparations<a class="anchor-link" href="#Preparations"> </a></h2>
</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description">
      <summary class="btn btn-sm" data-open="Hide Code" data-close="Show Code"></summary>
        <p><div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># collapse-hide</span>

<span class="c1">##### PACKAGES</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">torch.nn</span> <span class="k">as</span> <span class="nn">nn</span>
<span class="kn">from</span> <span class="nn">torch.utils.data</span> <span class="kn">import</span> <span class="n">Dataset</span><span class="p">,</span> <span class="n">DataLoader</span>

<span class="o">!</span>pip install timm
<span class="kn">import</span> <span class="nn">timm</span>

<span class="kn">import</span> <span class="nn">albumentations</span> <span class="k">as</span> <span class="nn">A</span>
<span class="kn">from</span> <span class="nn">albumentations.pytorch</span> <span class="kn">import</span> <span class="n">ToTensorV2</span>

<span class="kn">import</span> <span class="nn">cv2</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="n">device</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s2">&quot;cuda&quot;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>
</p>
    </details>
</div>
    

    
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description">
      <summary class="btn btn-sm" data-open="Hide Code" data-close="Show Code"></summary>
        <p><div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># collapse-hide</span>

<span class="c1">##### DATASET</span>


<span class="k">class</span> <span class="nc">ImageData</span><span class="p">(</span><span class="n">Dataset</span><span class="p">):</span>
    <span class="c1"># init</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">directory</span><span class="p">,</span> <span class="n">transform</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">directory</span> <span class="o">=</span> <span class="n">directory</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transform</span> <span class="o">=</span> <span class="n">transform</span>

    <span class="c1"># length</span>
    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

    <span class="c1"># get item</span>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="c1"># import</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span>
            <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">directory</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="s2">&quot;image_id&quot;</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2RGB</span><span class="p">)</span>

        <span class="c1"># augmentations</span>
        <span class="n">image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">image</span><span class="o">=</span><span class="n">image</span><span class="p">)[</span><span class="s2">&quot;image&quot;</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">image</span>
</pre></div>

    </div>
</div>
</div>
</p>
    </details>
</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We will use a standrd <code>PyTorch</code> dataloader to load the data in batches of 32 images.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description" open="">
      <summary class="btn btn-sm" data-open="Hide Code" data-close="Show Code"></summary>
        <p><div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># collapse-show</span>

<span class="c1">##### DATA LOADER</span>

<span class="c1"># import data</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s2">&quot;../input/cassava-leaf-disease-classification/train.csv&quot;</span><span class="p">)</span>
<span class="n">display</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">head</span><span class="p">())</span>

<span class="c1"># augmentations</span>
<span class="n">transforms</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">Compose</span><span class="p">([</span><span class="n">A</span><span class="o">.</span><span class="n">Resize</span><span class="p">(</span><span class="n">height</span><span class="o">=</span><span class="mi">128</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">128</span><span class="p">),</span> <span class="n">A</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(),</span> <span class="n">ToTensorV2</span><span class="p">()])</span>

<span class="c1"># dataset</span>
<span class="n">data_set</span> <span class="o">=</span> <span class="n">ImageData</span><span class="p">(</span>
    <span class="n">data</span><span class="o">=</span><span class="n">df</span><span class="p">,</span>
    <span class="n">directory</span><span class="o">=</span><span class="s2">&quot;../input/cassava-leaf-disease-classification/train_images/&quot;</span><span class="p">,</span>
    <span class="n">transform</span><span class="o">=</span><span class="n">transforms</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1"># dataloader</span>
<span class="n">data_loader</span> <span class="o">=</span> <span class="n">DataLoader</span><span class="p">(</span><span class="n">data_set</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">num_workers</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>
</p>
    </details>
<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_html rendered_html output_subarea ">
<div>
<style scoped="">
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>image_id</th>
      <th>label</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1000015157.jpg</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1000201771.jpg</td>
      <td>3</td>
    </tr>
    <tr>
      <th>2</th>
      <td>100042118.jpg</td>
      <td>1</td>
    </tr>
    <tr>
      <th>3</th>
      <td>1000723321.jpg</td>
      <td>1</td>
    </tr>
    <tr>
      <th>4</th>
      <td>1000812911.jpg</td>
      <td>3</td>
    </tr>
  </tbody>
</table>
</div>
</div>

</div>

</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Model">Model<a class="anchor-link" href="#Model"> </a></h2><p>To extract anything from a neural net, we first need to set up this net, right? In the cell below, we define a simple <code>resnet18</code> model with a two-node output layer. We use <code>timm</code> library to instantiate the model, but feature extraction will also work with any neural network written in <code>PyTorch</code>.</p>
<p>We also print out the architecture of our network. As you can see, there are many intermediate layers through which our image travels during a forward pass before turning into a two-number output. We should note the names of the layers because we will need to provide them to a feature extraction function.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">##### DEFINE MODEL</span>

<span class="n">model</span> <span class="o">=</span> <span class="n">timm</span><span class="o">.</span><span class="n">create_model</span><span class="p">(</span><span class="n">model_name</span><span class="o">=</span><span class="s2">&quot;resnet18&quot;</span><span class="p">,</span> <span class="n">pretrained</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">model</span><span class="o">.</span><span class="n">fc</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="mi">512</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">model</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>ResNet(
  (conv1): Conv2d(3, 64, kernel_size=(7, 7), stride=(2, 2), padding=(3, 3), bias=False)
  (bn1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
  (act1): ReLU(inplace=True)
  (maxpool): MaxPool2d(kernel_size=3, stride=2, padding=1, dilation=1, ceil_mode=False)
  (layer1): Sequential(
    (0): BasicBlock(
      (conv1): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (bn1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (act1): ReLU(inplace=True)
      (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (bn2): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (act2): ReLU(inplace=True)
    )
    (1): BasicBlock(
      (conv1): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (bn1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (act1): ReLU(inplace=True)
      (conv2): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (bn2): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (act2): ReLU(inplace=True)
    )
  )
 
 ... 
 
 (layer4): Sequential(
    (0): BasicBlock(
      (conv1): Conv2d(256, 512, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False)
      (bn1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (act1): ReLU(inplace=True)
      (conv2): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (bn2): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (act2): ReLU(inplace=True)
      (downsample): Sequential(
        (0): Conv2d(256, 512, kernel_size=(1, 1), stride=(2, 2), bias=False)
        (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      )
    )
    (1): BasicBlock(
      (conv1): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (bn1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (act1): ReLU(inplace=True)
      (conv2): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False)
      (bn2): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
      (act2): ReLU(inplace=True)
    )
  )
  (global_pool): SelectAdaptivePool2d (pool_type=avg, flatten=True)
  (fc): Linear(in_features=512, out_features=2, bias=True)
)</pre>
</div>

</div>

</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Feature-extraction">Feature extraction<a class="anchor-link" href="#Feature-extraction"> </a></h2><p>The implementation of feature extraction requires two simple steps:</p>
<ol>
<li>Registering a forward hook on a certain layer of the network.</li>
<li>Performing standard inference to extract features of that layer.</li>
</ol>
<p>First, we need to define a helper function that will introduce a so-called hook. A hook is simply a command that is executed when a forward or backward call to a certain layer is performed. If you want to know more about hooks, you can check out <a href="https://blog.paperspace.com/pytorch-hooks-gradient-clipping-debugging/">this link</a>.</p>
<p>In out setup, we are interested in a forward hook that simply copies the layer outputs, sends them to CPU and saves them to a dictionary object we call <code>features</code>.</p>
<p>The hook is defined in a cell below. The <code>name</code> argument in <code>get_features()</code> specifies the dictionary key under which we will store our intermediate activations.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">##### HELPER FUNCTION FOR FEATURE EXTRACTION</span>


<span class="k">def</span> <span class="nf">get_features</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">hook</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">output</span><span class="p">):</span>
        <span class="n">features</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">hook</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>After the helper function is defined, we can register a hook using <code>.register_forward_hook()</code> method. The hook can be applied to any layer of the neural network.</p>
<p>Since we work with a CNN, extracting features from the last convolutional layer might be useful to get image embeddings. Therefore, we are registering a hook for the outputs of the <code>(global_pool)</code>. To extract features from an earlier layer, we could also access them with, e.g., <code>model.layer1[1].act2</code> and save it under a different name in the <code>features</code> dictionary. With this method, we can actually register multiple hooks (one for every layer of interest), but we will only keep one for the purpose of this example.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">##### REGISTER HOOK</span>

<span class="n">model</span><span class="o">.</span><span class="n">global_pool</span><span class="o">.</span><span class="n">register_forward_hook</span><span class="p">(</span><span class="n">get_features</span><span class="p">(</span><span class="s2">&quot;feats&quot;</span><span class="p">))</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>&lt;torch.utils.hooks.RemovableHandle at 0x7f2540254290&gt;</pre>
</div>

</div>

</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now we are ready to extract features! The nice thing about hooks is that we can now perform inference as we usually would and get multiple outputs at the same time:</p>
<ul>
<li>outputs of the final layer</li>
<li>outputs of every layer with a registered hook</li>
</ul>
<p>The feature extraction happens automatically during the forward pass whenever we run <code>model(inputs)</code>. To store intermediate features and concatenate them over batches, we just need to include the following in our inference loop:</p>
<ol>
<li>Create placeholder list <code>FEATS = []</code>. This list will store intermediate outputs from all batches.</li>
<li>Create placeholder dict <code>features = {}</code>. We will use this dictionary for storing intermediate outputs from each batch.</li>
<li>Iteratively extract batch features to <code>features</code>, send them to CPU and append to the list <code>FEATS</code>. </li>
</ol>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">##### FEATURE EXTRACTION LOOP</span>

<span class="c1"># placeholders</span>
<span class="n">PREDS</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">FEATS</span> <span class="o">=</span> <span class="p">[]</span>

<span class="c1"># placeholder for batch features</span>
<span class="n">features</span> <span class="o">=</span> <span class="p">{}</span>

<span class="c1"># loop through batches</span>
<span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">inputs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data_loader</span><span class="p">):</span>
    <span class="c1"># move to device</span>
    <span class="n">inputs</span> <span class="o">=</span> <span class="n">inputs</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>

    <span class="c1"># forward pass [with feature extraction]</span>
    <span class="n">preds</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>

    <span class="c1"># add feats and preds to lists</span>
    <span class="n">PREDS</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">preds</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span>
    <span class="n">FEATS</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">features</span><span class="p">[</span><span class="s2">&quot;feats&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span>

    <span class="c1"># early stop</span>
    <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="mi">9</span><span class="p">:</span>
        <span class="k">break</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>This is it! Looking at the shapes of resulting arrays, you can see that the code worked well: we extracted both final layer outputs as <code>PREDS</code> and intermediate activations as <code>FEATS</code>. We can now save these features and work with them further.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">##### INSPECT FEATURES</span>

<span class="n">PREDS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">PREDS</span><span class="p">)</span>
<span class="n">FEATS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">FEATS</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;- preds shape:&quot;</span><span class="p">,</span> <span class="n">PREDS</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;- feats shape:&quot;</span><span class="p">,</span> <span class="n">FEATS</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>- preds shape: (320, 2)
- feats shape: (320, 512)
</pre>
</div>
</div>

</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="4.-Closing-words">4. Closing words<a class="anchor-link" href="#4.-Closing-words"> </a></h1><p>The purpose of this tutorial was to learn you how to extract intermediate outputs from the most interesting layers of your neural networks. With hooks, you can do all feature extraction in a single inference run and avoid complex modifications of your model. I hope you found this post helpful.</p>
<p>If you are interested, check out my other blog posts to see more tips on deep learning and <code>PyTorch</code>. Happy learning!</p>

</div>
</div>
</div>
</div>]]></content><author><name>Nikita Kozodoi</name></author><category term="python" /><category term="deep learning" /><category term="pytorch" /><category term="tutorial" /><summary type="html"><![CDATA[Simple way to extract activations from deep networks with hooks]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://kozodoi.me/images/posts/extraction.png" /><media:content medium="image" url="https://kozodoi.me/images/posts/extraction.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Tracking ML Experiments with Neptune.ai</title><link href="https://kozodoi.me/blog/20210430/tracking-experiments" rel="alternate" type="text/html" title="Tracking ML Experiments with Neptune.ai" /><published>2021-04-30T00:00:00-05:00</published><updated>2021-04-30T00:00:00-05:00</updated><id>https://kozodoi.me/blog/20210430/neptune</id><content type="html" xml:base="https://kozodoi.me/blog/20210430/tracking-experiments"><![CDATA[<!--
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: _notebooks/2021-04-30-neptune.ipynb
-->

<div class="container" id="notebook-container">
        
    
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><em>This post is also published on the <a href="https://neptune.ai/blog/switching-from-spreadsheets-to-neptune-ai">Neptune.ai blog</a></em>. All opinions are my own.*</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="1.-Introduction">1. Introduction<a class="anchor-link" href="#1.-Introduction"> </a></h1><p>Many ML projects, including Kaggle competitions, have a similar workflow. You start with a simple pipeline with a benchmark model. Next, you begin incorporating improvements: adding features, augmenting the data, tuning the model... On each iteration, you evaluate your solution and keep changes that improve the target metric.</p>
<p><img src="/images/copied_from_nb/images/fig_experiments.png" alt="" /></p>
<p align="center"><em>The figure illustrates the iterative improvement process in ML projects.</em></p>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>This workflow involves running a lot of experiments. As time goes by, it becomes difficult to keep track of the progress and positive changes. Instead of working on new ideas, you spend time thinking:</p>
<ul>
<li>“have I already tried this thing?”,</li>
<li>“what was that hyperparameter value that worked so well last week?” </li>
</ul>
<p>You end up running the same stuff multiple times. If you are not tracking your experiments yet, I highly recommend you to start!
In my previous Kaggle projects, I used to rely on spreadsheets for tracking. It worked very well in the beginning, but soon I realized that setting up and managing spreadsheets with experiment meta-data requires loads of additional work. I got tired of manually filling in model parameters and performance values after each experiment and really wanted to switch to an automated solution.</p>
<p>This is when I discovered Neptune.ai. This tool allowed me to save a lot of time and focus on modeling decisions, which helped me to earn three medals in Kaggle competitions.</p>
<p>In this post, I will share my story of switching from spreadsheets to Neptune for experiment tracking. I will describe a few disadvantages of spreadsheets, explain how Neptune helps to address them, and give a couple of tips on using Neptune for Kaggle.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="2.-What-is-wrong-with-spreadsheets-for-experiment-tracking?">2. What is wrong with spreadsheets for experiment tracking?<a class="anchor-link" href="#2.-What-is-wrong-with-spreadsheets-for-experiment-tracking?"> </a></h1><p>Spreadsheets are great for many purposes. To track experiments, you can simply set up a spreadsheet with different columns containing the relevant parameters and performance of your pipeline. It is also easy to share this spreadsheet with teammates.</p>
<p>Sounds great, right?</p>
<p>Unfortunately, there are a few problems with this.</p>
<p><img src="/images/copied_from_nb/images/fig_track_spreadsheets.png" alt="" /></p>
<p align="center"><em>The figure illustrates ML experiment tracking with spreadsheets.</em></p>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Manual-work">Manual work<a class="anchor-link" href="#Manual-work"> </a></h2><p>After doing it for a while, you will notice that maintaining a spreadsheet starts eating too much time. You need to manually fill in a row with meta-data for each new experiment and add a column for each new parameter. This will get out of control once your pipeline becomes more sophisticated.</p>
<p>It is also very easy to make a typo, which can lead to bad decisions.</p>
<p>When working on one deep learning competition, I incorrectly entered a learning rate in one of my experiments. Looking at the spreadsheet, I concluded that a high learning rate decreases the accuracy and went on working on other things. It was only a few days later when I realized that there was a typo and poor performance actually comes from a low learning rate. This cost me two days of work invested in the wrong direction based on a false conclusion.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="No-live-tracking">No live tracking<a class="anchor-link" href="#No-live-tracking"> </a></h2><p>With spreadsheets, you need to wait until an experiment is completed in order to record the performance.</p>
<p>Apart from being frustrated to do it manually every time, this also does not allow you to compare intermediate results across the experiments, which is helpful to see if a new run looks promising.</p>
<p>Of course, you can log in model performance after every epoch, but doing it manually for each experiment requires even more time and effort. I never had enough diligence to do it regularly and ended up spending some computing resources not optimally.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Attachment-limitations">Attachment limitations<a class="anchor-link" href="#Attachment-limitations"> </a></h2><p>Another issue with spreadsheets is that they only support textual meta-data that can be entered in a cell.</p>
<p>What if you want to attach other meta-data like:</p>
<ul>
<li>model weights, </li>
<li>source code, </li>
<li>plots with model predictions,</li>
<li>input data version?</li>
</ul>
<p>You need to manually store this stuff in your project folders outside of the spreadsheet.</p>
<p>In practice, it gets complicated to organize and sync experiment outputs between local machines, Google Colab, Kaggle Notebooks, and other environments your teammates might use. Having such meta-data attached to a tracking spreadsheet seems useful, but it is very difficult to do it.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="3.-Switching-from-spreadsheets-to-Neptune">3. Switching from spreadsheets to Neptune<a class="anchor-link" href="#3.-Switching-from-spreadsheets-to-Neptune"> </a></h1><p>A few months ago, our team was working on a Cassava Leaf Disease competition and used Google spreadsheets for experiment tracking. One month into the challenge, our spreadsheet was already cluttered:</p>
<ul>
<li>Some runs were missing performance because one of us forgot to log it in and did not have the results anymore. </li>
<li>PDFs with loss curves were scattered over Google Drive and Kaggle Notebooks. </li>
<li>Some parameters might have been entered incorrectly, but it was too time-consuming to restore and double-check older script versions. </li>
</ul>
<p>It was difficult to make good data-driven decisions based on our spreadsheet.</p>
<p>Even though there were only four weeks left, we decided to switch to Neptune. I was surprised to see how little effort it actually took us to set it up. In brief, there are three main steps:</p>
<ul>
<li>sign up for a Neptune account and create a project,</li>
<li>install the neptune package in your environment,</li>
<li>include several lines in the pipeline to enable logging of relevant meta-data.</li>
</ul>
<p>You can read more about the exact steps to start using Neptune here. Of course, going through the documentation and getting familiar with the platform may take you a few hours. But remember that this is only a one-time investment. After learning the tool once, I was able to automate much of the tracking and rely on Neptune in the next Kaggle competitions with very little extra effort</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="4.-What-is-good-about-Neptune?">4. What is good about Neptune?<a class="anchor-link" href="#4.-What-is-good-about-Neptune?"> </a></h1><p><img src="/images/copied_from_nb/images/fig_track_neptune.png" alt="" /></p>
<p align="center"><em>The figure illustrates ML experiment tracking with Neptune.</em></p>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Less-manual-work">Less manual work<a class="anchor-link" href="#Less-manual-work"> </a></h2><p>One of the key advantages of Neptune over spreadsheets is that it saves you a lot of manual work. With Neptune, you use the API within the pipeline to automatically upload and store meta-data while the code is running.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">neptune.new</span> <span class="k">as</span> <span class="nn">neptune</span>

<span class="n">run</span> <span class="o">=</span> <span class="n">neptune</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">project</span> <span class="o">=</span> <span class="s1">&#39;#&#39;</span><span class="p">,</span> <span class="n">api_token</span> <span class="o">=</span> <span class="s1">&#39;#&#39;</span><span class="p">)</span> <span class="c1"># your credentials</span>

<span class="c1"># Track relevant parameters</span>
<span class="n">config</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;batch_size&#39;</span><span class="p">:</span> <span class="mi">64</span><span class="p">,</span>
    <span class="s1">&#39;learning_rate&#39;</span><span class="p">:</span> <span class="mf">0.001</span><span class="p">,</span>
    <span class="s1">&#39;optimizer&#39;</span><span class="p">:</span> <span class="s1">&#39;Adam&#39;</span>
    <span class="p">}</span>
<span class="n">run</span><span class="p">[</span><span class="s1">&#39;parameters&#39;</span><span class="p">]</span> <span class="o">=</span>  <span class="n">config</span>

<span class="c1"># Track the training process by logging your training metrics</span>
<span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span>
    <span class="n">run</span><span class="p">[</span><span class="s1">&#39;train/accuracy&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">epoch</span> <span class="o">*</span> <span class="mf">0.6</span><span class="p">)</span>

<span class="c1"># Log the final results</span>
<span class="n">run</span><span class="p">[</span><span class="s1">&#39;f1_score&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.66</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>You don’t have to manually put it in the results table, and you also save yourself from making a typo. Since the meta-data is sent to Neptune directly from the code, you will get all numbers right no matter how many digits they have.</p>
<p>It may sound like a small thing, but the time saved from logging in each experiment accumulates very quickly and leads to tangible gains by the end of the project. This gives you an opportunity to not think too much about the actual tracking process and better focus on the modeling decisions. In a way, this is like hiring an assistant to take care of some boring (but very useful) logging tasks so that you can focus more on the creative work.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Live-tracking">Live tracking<a class="anchor-link" href="#Live-tracking"> </a></h2><p>What I like a lot about Neptune is that it allows you to do live tracking. If you work with models like neural networks or gradient boosting that require a lot of iterations before convergence, you know it is quite useful to look at the loss dynamics early to detect issues and compare models.</p>
<p>Tracking intermediate results in a spreadsheet is too frustrating. Neptune API can log in performance after every epoch or even every batch so that you can start comparing the learning curves while your experiment is still running.</p>
<p><img src="/images/copied_from_nb/images/fig_curves.png" alt="" /></p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>This proves to be very helpful. As you might expect, many ML experiments have negative results (sorry, but this great idea you were working on for a few days actually decreases the accuracy).</p>
<p>This is completely fine because this is how ML works.</p>
<p>What is not fine is that you may need to wait a long time until getting that negative signal from your pipeline. Using Neptune dashboard to compare the intermediate plots with the first few performance values may be enough to realize that you need to stop the experiment and change something.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Attaching-outputs">Attaching outputs<a class="anchor-link" href="#Attaching-outputs"> </a></h2><p>Another advantage of Neptune is the ability to attach pretty much anything to every experiment run. This really helps to keep important outputs such as model weights and predictions in one place and easily access them from your experiments table.</p>
<p>This is particularly helpful if you and your colleagues work in different environments and have to manually upload the outputs to sync the files.</p>
<p>I also like the ability to attach the source code to each run to make sure you have the notebook version that produced the corresponding result. This can be very useful in case you want to revert some changes that did not improve the performance and would like to go back to the previous best version.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="4.-Tips-to-improve-Kaggle-performance-with-Neptune">4. Tips to improve Kaggle performance with Neptune<a class="anchor-link" href="#4.-Tips-to-improve-Kaggle-performance-with-Neptune"> </a></h1><p>When working on Kaggle competitions, there are a few tips I can give you to further improve your tracking experience.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Using-Neptune-in-Kaggle-Notebooks-or-Google-Colab">Using Neptune in Kaggle Notebooks or Google Colab<a class="anchor-link" href="#Using-Neptune-in-Kaggle-Notebooks-or-Google-Colab"> </a></h2><p>First, Neptune is very helpful for working in Kaggle Notebooks or Google Colab that have session time limits when using GPU/TPU. I can not count how many times I lost all experiment outputs due to a notebook crash when training was taking just a few minutes more than the allowed 9-hour limit!</p>
<p>To avoid that, I would highly recommend setting up Neptune such that model weights and loss metrics are stored after each epoch. That way, you will always have a checkpoint uploaded to Neptune servers to resume your training even if your Kaggle notebook times out. You will also have an opportunity to compare your intermediate results before the session crash with other experiments to judge their potential.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Updating-runs-with-the-Kaggle-leaderboard-score">Updating runs with the Kaggle leaderboard score<a class="anchor-link" href="#Updating-runs-with-the-Kaggle-leaderboard-score"> </a></h2><p>Second, an important metric to track in Kaggle projects is the leaderboard score. With Neptune, you can track your cross-validation score automatically but getting the leaderboard score inside the code is not possible since it requires you to submit predictions via the Kaggle website.</p>
<p>The most convenient way to add the leaderboard score of your experiment to the Neptune tracking table is to use the "resume run" functionality. It allows you to update any finished experiment with a new metric with a couple of lines of code. This feature is also helpful to resume tracking crashed sessions, which we discussed in the previous paragraph.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">neptune.new</span> <span class="k">as</span> <span class="nn">neptune</span>

<span class="n">run</span> <span class="o">=</span> <span class="n">neptune</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">project</span> <span class="o">=</span> <span class="s1">&#39;Your-Kaggle-Project&#39;</span><span class="p">,</span> <span class="n">run</span> <span class="o">=</span> <span class="s1">&#39;SUN-123&#39;</span><span class="p">)</span>

<span class="c1"># Add a new metric</span>
<span class="n">run</span><span class="p">[</span><span class="err">“</span><span class="n">LB_score</span><span class="err">”</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span>

<span class="c1"># Download snapshot of model weights</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">run</span><span class="p">[</span><span class="s1">&#39;train/model_weights&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">download</span><span class="p">()</span>

<span class="c1"># Continue working</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Downloading-experiment-meta-data">Downloading experiment meta-data<a class="anchor-link" href="#Downloading-experiment-meta-data"> </a></h2><p>Finally, I know that many Kagglers like to perform complex analyses of their submissions, like estimating the correlation between CV and LB scores or plotting the best score dynamics with respect to time.</p>
<p>While it is not yet feasible to do such things on the website, Neptune allows you to download meta-data from all experiments directly into your notebook using a single API call. It makes it easy to take a deeper dive into the results or export the meta-data table and share it externally with people who use a different tracking tool or don’t rely on any experiment tracking.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">neptune.new</span> <span class="k">as</span> <span class="nn">neptune</span>

<span class="n">my_project</span> <span class="o">=</span> <span class="n">neptune</span><span class="o">.</span><span class="n">get_project</span><span class="p">(</span><span class="s1">&#39;Your-Workspace/Your-Kaggle-Project&#39;</span><span class="p">)</span>

<span class="c1"># Get dashboard with runs contributed by &#39;sophia&#39;</span>
<span class="n">sophia_df</span> <span class="o">=</span> <span class="n">my_project</span><span class="o">.</span><span class="n">fetch_runs_table</span><span class="p">(</span><span class="n">owner</span> <span class="o">=</span> <span class="s1">&#39;sophia&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">to_pandas</span><span class="p">()</span>
<span class="n">sophia_df</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="5.-Final-thoughts">5. Final thoughts<a class="anchor-link" href="#5.-Final-thoughts"> </a></h1><p>In this post, I shared my story of switching from spreadsheets to Neptune for tracking ML experiments and emphasized some advantages of Neptune. I would like to stress once again that investing time in infrastructure tools - be it experiment tracking, code versioning, or anything else - is always a good decision and will likely pay off with the increased productivity.
Tracking experiment meta-data with spreadsheets is much better than not doing any tracking. It will help you to better see your progress, understand what modifications improve your solution, and help make modeling decisions. Doing it with spreadsheets will also cost you some additional time and effort. Tools like Neptune take the experiment tracking to a next level, allowing you to automate the meta-data logging and focus on the modeling decisions.</p>
<p>I hope you find my story useful. Good luck with your future ML projects!</p>

</div>
</div>
</div>
</div>]]></content><author><name>Nikita Kozodoi</name></author><category term="python" /><category term="infrastructure" /><summary type="html"><![CDATA[Switching from spreadsheets to Neptune to improve model building]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://kozodoi.me/images/posts/neptune.png" /><media:content medium="image" url="https://kozodoi.me/images/posts/neptune.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>